# SYNTAX TEST "TCL2.sublime-syntax"

##############################################################################
# [1] Commands
#
# A Tcl script is a string containing one or more commands. Semicolons and
# newlines are command separators unless quoted as described below. Close
# brackets are command terminators during command substitution unless quoted.
##############################################################################

    cmd arg1 arg2; cmd arg1 arg2
#  ^ - meta.function-call
#   ^^^^^^^^^^^^^^ meta.function-call.tcl
#                ^ punctuation.terminator.command.tcl
#                 ^ - meta
#                  ^^^^^^^^^^^^^^ meta.function-call.tcl

    [cmd arg][cmd arg] {puts "str"}

    "cmd" arg arg

    {cmd} arg arg

    $cmd  arg arg

    ${cmd(test)} arg arg


##############################################################################
# [3] Words
#
# Words of a command are separated by white space
# (except for newlines, which are command separators).
##############################################################################


##############################################################################
# [4] Double quotes
#
# If the first character of a word is double quote (“"”) then the word is
# terminated by the next double quote character. Semicolons, close brackets,
# or white space characters (including newlines) are treated as ordinary
# characters and included in the word.
##############################################################################

    "foo } ] ; # bar \" \
#   ^ punctuation.definition.string.begin.tcl
#   ^^^^^^^^^^^^^^^^^ string.quoted.double.tcl
#        ^ - punctuation
#          ^ - punctuation
#            ^ - punctuation
#              ^ - punctuation
#              ^^^^^^^^ - comment
#                    ^^ constant.character.escape.other.tcl
#                       ^ - punctuation
    "
#^^^^ string.quoted.double.tcl
#   ^ punctuation.definition.string.end.tcl
#    - string - punctuation

# Command substitution, variable substitution, and backslash substitution are performed
    "$foo ${bar + 2} [baz]"
#  ^ - string - punctuation
#   ^ punctuation.definition.string.begin.tcl
#   ^^^^^^^^^^^^^^^^^^^^^^^ string.quoted.double.tcl
#    ^ punctuation.definition.variable.tcl
#    ^^^^ variable.other.tcl
#        ^ - variable.other
#         ^^ punctuation.definition.variable.begin.tcl
#         ^^^^^^^^^^ variable.other.tcl
#                  ^ punctuation.definition.variable.end.tcl
#                   ^ - variable.other
#                    ^ punctuation.section.substitution.begin.tcl
#                    ^^^^^ meta.substitution.tcl
#                        ^ punctuation.section.substitution.end.tcl
#                         ^ punctuation.definition.string.end.tcl
#                          ^ - string - punctuation


# backslash substitution
    "foo $bar # baz ${bar + 2} [proc eval {}] \h \" "


##############################################################################
# [5] Argument expansion
#
# If a word starts with the string “{*}” followed by a non-whitespace character,
# then the leading “{*}” is removed and the rest of the word is parsed and
# substituted as any other word.
##############################################################################

    cmd a {*}{b [c]} d {*}{$e f {g h}} {*} {1 2 3}
#         ^^^ keyword.operator.word.tcl
#            ^ punctuation.section.braces.begin.tcl
#            ^^^^^^^ meta.braces.tcl - keyword.operator.word
#                  ^ punctuation.section.braces.end.tcl
#                         ^ punctuation.section.braces.begin.tcl
#                         ^^^^^^^^^^^^ meta.braces.tcl - keyword.operator.word
#                               ^ punctuation.section.braces.begin.tcl
#                               ^^^^^ meta.braces.tcl meta.braces.tcl
#                                   ^^ punctuation.section.braces.end.tcl
#                                      ^ punctuation.section.braces.begin.tcl
#                                      ^^^ meta.braces.tcl - keyword.operator.word
#                                        ^ punctuation.section.braces.end.tcl
#                                          ^ punctuation.section.braces.begin.tcl
#                                          ^^^^^^^ meta.braces.tcl - keyword.operator.word
#                                                ^ punctuation.section.braces.end.tcl


##############################################################################
# [6] Braces
#
# If the first character of a word is an open brace (“{”) and rule [5] does
# not apply, then the word is terminated by the matching close brace (“}”).
# Braces nest within the word: for each additional open brace there must be an
# additional close brace (however, if an open brace or close brace within the
# word is quoted with a backslash then it is not counted in locating the
# matching close brace). No substitutions are performed on the characters
# between the braces except for backslash-newline substitutions described
# below, nor do semi-colons, newlines, close brackets, or white space receive
# any special interpretation. The word will consist of exactly the characters
# between the outer braces, not including the braces themselves.
##############################################################################

    {}
#  ^ - meta.braces - punctuation
#   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#    ^ meta.braces.tcl punctuation.section.braces.end.tcl
#     ^ - meta.braces - punctuation

    {
#  ^ - meta.braces - punctuation
#   ^ punctuation.section.braces.begin.tcl
#   ^^ meta.braces.tcl
    }
#^^^^ meta.braces.tcl
#   ^ punctuation.section.braces.end.tcl
#    ^ - meta.braces - punctuation

    { {\} \{} \n \x10 ; ] $novar ${foo(bar,baz)} }
#  ^ - meta.braces - punctuation
#   ^ punctuation.section.braces.begin.tcl
#   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.braces.tcl
#     ^ punctuation.section.braces.begin.tcl
#     ^^^^^^^ meta.braces.tcl meta.braces.tcl
#      ^^ constant.character.escape.other.tcl - punctuation.section.braces
#         ^^ constant.character.escape.other.tcl - punctuation.section.braces
#           ^ punctuation.section.braces.end.tcl
#             ^^ constant.character.escape.other.tcl
#                ^^^^ - constant.character.escape
#                     ^ - punctuation
#                       ^ - punctuation
#                         ^^^^^^ - variable.other
#                                ^^^^^^^^^^^^^^^ - variable.other
#                                 ^ punctuation.section.braces.begin.tcl
#                                 ^^^^^^^^^^^^^^ meta.braces.tcl meta.braces.tcl
#                                     ^ - punctuation
#                                         ^ - punctuation
#                                             ^ - punctuation
#                                              ^ punctuation.section.braces.end.tcl
#                                                ^ punctuation.section.braces.end.tcl
#                                                 ^ - meta.braces - punctuation


##############################################################################
# [7] Command substitution
##############################################################################

    []
#  ^ - meta.substitution
#   ^^ meta.substitution.tcl
#   ^ punctuation.section.substitution.begin.tcl
#    ^ punctuation.section.substitution.end.tcl
#     ^ - meta.substitution

    [cmd a b][expr 1 + 5] arg arg
#  ^ - meta.substitution
#   ^ punctuation.section.substitution.begin.tcl
#   ^^^^^^^^^^^^^^^^^^^^^ meta.substitution.tcl
#           ^ punctuation.section.substitution.end.tcl
#            ^ punctuation.section.substitution.begin.tcl
#                       ^ punctuation.section.substitution.end.tcl
#                        ^ - meta.substitution.tcl
#                         ^^^ - keyword

    [
#  ^ - meta.substitution - punctuation
#   ^ punctuation.section.substitution.begin.tcl
#   ^^ meta.substitution.tcl
      proc A {a b c} {

      }
    ]
# <- meta.substitution.tcl
#^^^^ meta.substitution.tcl
#   ^ punctuation.section.substitution.end.tcl
#    ^ - meta.substitution - punctuation

    set y [set x 0][incr x][incr x]
#  ^ - meta
#        ^ - meta.substitution
#         ^^^^^^^^^^^^^^^^^^^^^^^^^ meta.substitution.tcl
#         ^ punctuation.section.substitution.begin.tcl
#                 ^ punctuation.section.substitution.end.tcl
#                  ^ punctuation.section.substitution.begin.tcl
#                         ^ punctuation.section.substitution.end.tcl
#                          ^ punctuation.section.substitution.begin.tcl
#                                 ^ punctuation.section.substitution.end.tcl
#                                  ^ - meta.substitution

# Command substitution is not performed on words enclosed in braces.
    set {bar [baz]}

    set saoid [svcmap_saoid sm]


##############################################################################
# [8] Variable substitution
#
# Name is the name of a scalar variable or array element. It may contain any
# characters whatsoever except for close braces. It indicates an array element
# if name is in the form “arrayName(index)” where arrayName does not contain
# any open parenthesis characters, “(”, or close brace characters, “}”, and
# index can be any sequence of characters except for close brace characters.
# No further substitutions are performed during the parsing of name.
##############################################################################

    cmd $var
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^ variable.other.tcl
#           ^ - variable.other

    cmd $var:novar
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^ variable.other.tcl
#           ^ - punctuation
#           ^^^^^^ - variable.other

    cmd pref$var[cmd arg]
#      ^^^^^ - variable.other
#           ^ punctuation.definition.variable.tcl
#           ^^^^ variable.other.tcl
#               ^ meta.substitution - variable.other

    cmd $ns::
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^^ variable.other.tcl
#          ^^ punctuation.accessor.colon.tcl
#            ^ - variable.other

    cmd $ns::var
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^^^^^ variable.other.tcl
#          ^^ punctuation.accessor.colon.tcl
#               ^ - variable.other

    cmd ${ns}::cmd
#      ^ - variable.other
#       ^^^^^ variable.other.tcl
#       ^^ punctuation.definition.variable.begin.tcl
#           ^ punctuation.definition.variable.end.tcl
#            ^^ punctuation.accessor.colon.tcl - variable.other

    cmd $var( arg , [set $var "x"] )
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ variable.other.tcl
#          ^ - meta.parens
#           ^ punctuation.section.parens.begin.tcl
#           ^^^^^^^^^^^^^^^^^^^^^^^^ meta.parens.tcl
#                 ^ punctuation.separator.sequence.tcl
#                   ^ punctuation.section.substitution.begin.tcl
#                   ^^^^^^^^^^^^^^ meta.substitution.tcl
#                    ^^^ keyword.other.builtin.tcl
#                        ^ punctuation.definition.variable.tcl
#                        ^^^^ variable.other.tcl variable.other.tcl
#                                ^ punctuation.section.substitution.end.tcl
#                                  ^ punctuation.section.parens.end.tcl
#                                   ^ - meta.parens - variable.other

    cmd $ns::var( arg , [set $var "x"] )
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ variable.other.tcl
#          ^^ punctuation.accessor.colon.tcl
#              ^ - meta.parens
#               ^ punctuation.section.parens.begin.tcl
#               ^^^^^^^^^^^^^^^^^^^^^^^^ meta.parens.tcl
#                     ^ punctuation.separator.sequence.tcl
#                       ^ punctuation.section.substitution.begin.tcl
#                       ^^^^^^^^^^^^^^ meta.substitution.tcl
#                        ^^^ keyword.other.builtin.tcl
#                            ^ punctuation.definition.variable.tcl
#                            ^^^^ variable.other.tcl variable.other.tcl
#                                    ^ punctuation.section.substitution.end.tcl
#                                      ^ punctuation.section.parens.end.tcl
#                                       ^ - meta.parens - variable.other

# Command substitutions, variable substitutions, and backslash substitutions
# are performed on the characters of index.

    cmd ${var-ia.b%le([set x 0], \U0B42[incr x]$idx)}
#      ^ - variable.other
#       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ variable.other.tcl
#       ^^ punctuation.definition.variable.begin.tcl
#                    ^ punctuation.section.parens.begin.tcl
#                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.parens.tcl
#                              ^ punctuation.separator.sequence.tcl
#                                                  ^ punctuation.section.parens.end.tcl
#                                                   ^ punctuation.definition.variable.end.tcl
#                                                    ^ - variable.other


# Variable substitution is not performed on words enclosed in braces.


    {$novar}

    {${name}}

    $name(idx1,idx2)

    ${arrayName(idx1,idx2)}


##############################################################################
# [9] Backslash substitution
##############################################################################

# Audible alert (bell) (0x7).
    \a
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Backspace (0x8).
    \b
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Form feed (0xc).
    \f
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Newline (0xa).
    \n
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Carriage-return (0xd).
    \r
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Tab (0x9).
    \t
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Vertical tab (0xb).
    \v
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Backslash
    \\
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Closing bracket
    \]
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Closing bracket
    \}
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Closing bracket
    \"
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Hashtag
    \#
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Eight-bit octal value for the Unicode character.
    \1
#  ^ - constant.character.escape
#   ^^ constant.character.escape.octal
#     ^ - constant.character.escape

    \19
#  ^ - constant.character.escape
#   ^^^ constant.character.escape.octal
#      ^ - constant.character.escape

    \152
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.octal
#       ^ - constant.character.escape

    \15232
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.octal
#       ^^^ - constant.character.escape

# Eight-bit hexadecimal value for the Unicode character.
# Any number of hexadecimal digits may be present; however, all but the last
# two are ignored (the result is always a one-byte quantity).
    \x
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

    \x1
#  ^ - constant.character.escape
#   ^^^ constant.character.escape.hexadecimal
#      ^ - constant.character.escape

    \x19
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.hexadecimal
#       ^ - constant.character.escape

    \x152
#  ^ - constant.character.escape
#   ^^^^^ constant.character.escape.hexadecimal
#        ^ - constant.character.escape

    \x1afbg
#  ^ - constant.character.escape
#   ^^^^^^ constant.character.escape.hexadecimal
#         ^^ - constant.character.escape

# A sixteen-bit hexadecimal value for the Unicode character
    \u
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

    \u0
#  ^ - constant.character.escape
#   ^^^ constant.character.escape.hexadecimal
#      ^ - constant.character.escape

    \u0a
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.hexadecimal
#       ^ - constant.character.escape

    \u0a5f
#  ^ - constant.character.escape
#   ^^^^^^ constant.character.escape.hexadecimal
#         ^ - constant.character.escape

    \u0ag
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.hexadecimal
#       ^ - constant.character.escape

    \u0a5fabcd
#  ^ - constant.character.escape
#   ^^^^^^ constant.character.escape.hexadecimal
#         ^^^^^ - constant.character.escape

# A thirty-two-bit hexadecimal value for the Unicode character
    \U
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

    \U0
#  ^ - constant.character.escape
#   ^^^ constant.character.escape.hexadecimal
#      ^ - constant.character.escape

    \U0a
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.hexadecimal
#       ^ - constant.character.escape

    \U0a5f
#  ^ - constant.character.escape
#   ^^^^^^ constant.character.escape.hexadecimal
#         ^ - constant.character.escape

    \U0a5g
#  ^ - constant.character.escape
#   ^^^^^ constant.character.escape.hexadecimal
#        ^ - constant.character.escape

    \U0a5fabcd
#  ^ - constant.character.escape
#   ^^^^^^^^^^ constant.character.escape.hexadecimal
#             ^ - constant.character.escape

    \U0a5fabcdddf
#  ^ - constant.character.escape
#   ^^^^^^^^^^ constant.character.escape.hexadecimal
#             ^^^^ - constant.character.escape


##############################################################################
# [10] Comments
#
# If a hash character (“#”) appears at a point where Tcl is expecting the
# first character of the first word of a command then the hash character and
# the characters that follow it, up through the next newline, are treated as a
# comment and ignored.
##############################################################################

    # command \
#  ^ - comment
#   ^ punctuation.definition.comment.begin.tcl
#   ^^^^^^^^^^^^ comment.line.double-dash.tcl
#             ^ - punctuation.separator.continuation.newline.tcl

    cmd#no comment
#      ^ - punctuation
#      ^^^^^^^^^^^^ - comment

    cmd # no comment
#       ^^^^^^^^^^^^^ - comment

    cmd;# no comment
#      ^ punctuation.terminator.command.tcl
#       ^ punctuation.definition.comment.begin.tcl
#       ^^^^^^^^^^^^^ comment.line.double-dash.tcl

    cmd ; # no comment
#       ^ meta.function-call.tcl punctuation.terminator.command.tcl
#         ^ punctuation.definition.comment.begin.tcl
#         ^^^^^^^^^^^^^ comment.line.double-dash.tcl

    cmd [# comment]
#       ^ punctuation.section.substitution.begin.tcl
#        ^ punctuation.definition.comment.begin.tcl
#        ^^^^^^^^^^^ comment.line.double-dash.tcl
#                 ^ - punctuation

        cmd [ set;# comment ];comment
#                ^ punctuation.terminator.command.tcl
#                 ^ punctuation.definition.comment.begin.tcl
#                 ^^^^^^^^^^^^^^^^^^^^ comment.line.double-dash.tcl
#                           ^^ - punctuation
            ]
#           ^ meta.substitution.tcl punctuation.section.substitution.end.tcl

        cmd [ set#no comment ]
#           ^ punctuation.section.substitution.begin.tcl
#                ^ - punctuation
#                ^^^^^^^^^^^^^^ - comment
#                            ^ punctuation.section.substitution.end.tcl

        cmd [ set # no comment ]
#           ^ punctuation.section.substitution.begin.tcl
#                 ^ - punctuation
#                 ^^^^^^^^^^^^^^^ - comment
#                              ^ punctuation.section.substitution.end.tcl
       ]
#      ^ punctuation.section.substitution.end.tcl

    set w { # no commet }
#           ^^^^^^^^^^^^^^ - comment

    set w { ; # no commet }
#             ^^^^^^^^^^^^^^ - comment


##############################################################################
# namespace tests
##############################################################################

    namespace \
#   ^^^^^^^^^ keyword.control.flow.namespace.tcl
#             ^ punctuation.separator.continuation.newline.tcl
    eval \
#   ^^^^ keyword.control.flow.eval.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    A \
#   ^ entity.name.namespace.tcl
#     ^ punctuation.separator.continuation.newline.tcl
    {
#^^^ meta.namespace.tcl - meta.braces
#   ^^ meta.namespace.tcl meta.braces
#   ^ punctuation.section.braces.begin.tcl
    }
#^^^^ meta.namespace.tcl meta.braces.tcl
#    ^ meta.namespace.tcl - meta.braces.tcl
#   ^ punctuation.section.braces.end.tcl


    namespace eval A {
#  ^ - meta
#   ^^^^^^^^^^^^^^^^^^^ meta.namespace
#                    ^^ meta.braces
#   ^^^^^^^^^ keyword.control.flow.namespace
#             ^^^^ keyword.control.flow.eval
#                  ^ entity.name.namespace
#                    ^ punctuation.section.braces.begin
        namespace eval B \
#^^^^^^^ meta.namespace
#       ^^^^^^^^^^^^^^^^^^^ meta.namespace meta.namespace
#                    ^^ meta.braces
#       ^^^^^^^^^ keyword.control.flow.namespace
#                 ^^^^ keyword.control.flow.eval
#                      ^ entity.name.namespace
#                        ^ punctuation.separator.continuation.newline
        {
#<- meta.namespace meta.namespace
#       ^ punctuation.section.braces.begin
            proc A {

            }

            proc [proc A {}] {

            }

        }
    }


##############################################################################
# flow control keyword tests
##############################################################################

    break invalid ; # comment
#   ^^^^^ keyword.control.flow.break.tcl
#        ^ - keyword - invalid
#         ^^^^^^^ invalid.illegal.command-end-expected.tcl
#                ^ - invalid
#                 ^ punctuation.terminator.command.tcl
#                   ^ comment.line.double-dash.tcl

    break-me
#   ^^^^^ - keyword.control.flow

    break[incr x]
#   ^^^^^ - keyword.control.flow

    break(5)
#   ^^^^^ - keyword.control.flow

    continue "test";# comment
#   ^^^^^^^^ keyword.control.flow.continue.tcl
#           ^ - keyword - invalid
#            ^^^^^^ invalid.illegal.command-end-expected.tcl
#                  ^ punctuation.terminator.command.tcl
#                   ^ comment.line.double-dash.tcl

    continue-me
#   ^^^^^^^^ - keyword.control.flow

    continue[incr x]
#   ^^^^^^^^ - keyword.control.flow

    continue(2)
#   ^^^^^^^^ - keyword.control.flow

    exit

    return
#  ^ - keyword
#   ^^^^^^ keyword.control.flow.return.tcl
#         ^ - keyword
    returnme
#   ^^^^^^^^^ - keyword.control.flow

    return(1)
#   ^^^^^^^^^ - keyword.control.flow

    return 1
#  ^ - keyword
#   ^^^^^^ keyword.control.flow.return.tcl
#         ^ - keyword
#          ^ constant.numeric.integer.tcl

    return -code $code $factor
#  ^ - keyword
#   ^^^^^^ keyword.control.flow.return.tcl
#         ^ - keyword
#          ^^^^^ variable.parameter.tcl
#                ^^^^^ variable.other.tcl
#                      ^^^^^^^ variable.other.tcl

    return -code error \
#  ^ - keyword
#   ^^^^^^ keyword.control.flow.return.tcl
#         ^ - keyword
#          ^^^^^ variable.parameter.tcl
#                ^^^^^ constant.language.tcl
        "overflow computing factorial of $n"
#       ^ string.quoted.double.tcl punctuation.definition.string.begin.tcl

##############################################################################
# if-else tests
##############################################################################

    if true {} elseif false {} else {} ; if false {cmd arg}
#   ^^ keyword.control.flow.if.tcl
#      ^^^^ constant.language.tcl
#           ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#            ^ meta.braces.tcl punctuation.section.braces.end.tcl
#              ^^^^^^ keyword.control.flow.elseif.tcl
#                     ^^^^^ constant.language.tcl
#                           ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#                            ^ meta.braces.tcl punctuation.section.braces.end.tcl
#                              ^^^^ keyword.control.flow.else.tcl
#                                   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#                                    ^ meta.braces.tcl punctuation.section.braces.end.tcl
#                                      ^ punctuation.terminator.command.tcl
#                                        ^^ keyword.control.flow.if.tcl
#                                           ^^^^^ constant.language.tcl
#                                                 ^ punctuation.section.braces.begin.tcl
#                                                 ^^^^^^^^^ meta.braces.tcl
#                                                         ^ punctuation.section.braces.end.tcl

# check line-continuation at all possible positions in statement
    if \
#   ^^ keyword.control.flow.if.tcl
#      ^ punctuation.separator.continuation.newline.tcl
    true \
#   ^^^^ constant.language.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    {cmd arg arg} \
#   ^ punctuation.section.braces.begin.tcl
#   ^^^^^^^^^^^^^ meta.braces.tcl
#    ^^^ variable.function.tcl
#               ^ punctuation.section.braces.end.tcl
#                 ^ punctuation.separator.continuation.newline.tcl
    elseif \
#   ^^^^^^ keyword.control.flow.elseif.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    false \
#   ^^^^^ constant.language.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    {} \
#   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#    ^ meta.braces.tcl punctuation.section.braces.end.tcl
#      ^ punctuation.separator.continuation.newline.tcl
    elseif \
#   ^^^^^^ keyword.control.flow.elseif.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    [puts \
#   ^ punctuation.section.substitution.begin.tcl
#   ^^^^^^^^ meta.substitution.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    "true"] \
# <- meta.substitution.tcl
#^^^^^^^^^^ meta.substitution.tcl
#   ^^^^^^ string.quoted.double.tcl
#         ^ punctuation.section.substitution.end.tcl
#           ^ punctuation.separator.continuation.newline.tcl
    {} \
#   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#    ^ meta.braces.tcl punctuation.section.braces.end.tcl
#      ^ punctuation.separator.continuation.newline.tcl
    else \
#   ^^^^ keyword.control.flow.else.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    {}
#   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#    ^ meta.braces.tcl punctuation.section.braces.end.tcl

# Ensure else doesn't work outside of if command
    elseif true {}
#   ^^^^^^ invalid.illegal.unexpected.tcl
#          ^^^^ constant.language.tcl
#               ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#                ^ meta.braces.tcl punctuation.section.braces.end.tcl
    else {}
#   ^^^^ invalid.illegal.unexpected.tcl
#        ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#         ^ meta.braces.tcl punctuation.section.braces.end.tcl

    if {$arg eq [set x]} {
#   ^^ keyword.control.flow.if.tcl
#      ^ punctuation.section.braces.begin.tcl
#      ^^^^^^^^^^^^^^^^^ meta.braces.tcl
#       ^^^^ variable.other.tcl
#            ^^ keyword.operator.relational.tcl
#               ^^^^^^^ meta.substitution.tcl
#                      ^ punctuation.section.braces.end.tcl
#                        ^^ meta.braces.tcl
#                        ^ punctuation.section.braces.begin.tcl
        set var 0

        if {$var == 0} {
            puts "bar"
        } else {
            puts "baz"
        }

    } elseif [puts "true"] {

        puts "foo"
    } else {
        puts "bar"
    }

##############################################################################
# for loop tests
##############################################################################


    # for loop execution
    for {set a 10} {$a < 20} {incr a} {
       puts "value of a: $a"
    }


    foreach i {
       GigabitEthernet1/18
       Serial2/2/0.1/2/1/1:0
       Serial2/2/0.1/2/1/2:0
       Serial2/2/0.1/2/1/3:0
       Serial2/2/0.1/2/2/1:0
       Serial2/2/0.1/2/2/2:0
       Serial2/2/0.1/2/2/3:0
       GigabitEthernet9/24
    } {
        set int [exec "show run inter $i | in Serial"]
        if {[regexp "Serial" $int ]} {
            puts "interface $i"
            puts "encap ppp"
        } else {
           puts "interface $i"
           puts "cdp enable"
           puts "Dampening"
           puts "no sh"
        }
    }

##############################################################################
# array commands
##############################################################################

    array set cpe_param [objectGetField -oid $cpeoid -fieldname parameters]
#   ^^^^^ keyword.other.builtin.tcl
#         ^^^ variable.function.tcl
#             ^^^^^^^^^ variable.other.tcl
#                       ^ punctuation.section.substitution.begin.tcl
#                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.substitution.tcl
#                                                                         ^ punctuation.section.substitution.end.tcl

    array names list_name -glob "pa?[A-z]ttern"
#   ^^^^^ keyword.other.builtin.tcl
#        ^ - keyword - variable
#         ^^^^^ variable.function.tcl
#              ^ - variable
#               ^^^^^^^^^ variable.other.tcl
#                        ^ - variable
#                         ^^^^^ variable.parameter.tcl
#                              ^ - variable - string
#                               ^ punctuation.definition.string.begin.tcl
#                               ^^^^^^^^^^^^^^^ string.quoted.double.tcl
#                                  ^ constant.other.placeholder.tcl
#                                   ^^^^^ meta.bracket.tcl constant.other.placeholder.tcl
#                                             ^ punctuation.definition.string.end.tcl
#                                              ^ - string

##############################################################################
# after commands
##############################################################################

    set id [after 10 [puts "done!"]]
#           ^^^^^ keyword.other.builtin.tcl

    after cancel $id
#   ^^^^^ keyword.other.builtin.tcl
#         ^^^^^^ constant.language.tcl
#                ^^^ variable.other.tcl

    after info $id
#   ^^^^^ keyword.other.builtin.tcl
#         ^^^^ constant.language.tcl
#              ^^^ variable.other.tcl

    after idle [list after 0 doOneStep]
#   ^^^^^ keyword.other.builtin.tcl
#         ^^^^ constant.language.tcl
#              ^^^^^^^^^^^^^^^^^^^^^^^^ meta.substitution.tcl

##############################################################################
# string commands
##############################################################################

    string compare $str1 $str2; string last $str3
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^^^ variable.function.string.tcl
#                  ^^^^^ variable.other.tcl
#                        ^^^^^ variable.other.tcl
#                             ^ punctuation.terminator.command.tcl
#                               ^^^^^^ keyword.other.builtin.tcl
#                                      ^^^^ variable.function.string.tcl
#                                           ^^^^^ variable.other.tcl
    string \
#   ^^^^^^ keyword.other.builtin.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    compare \
#   ^^^^^^^ variable.function.string.tcl
#           ^ punctuation.separator.continuation.newline.tcl
    $str1 \
#   ^^^^^ variable.other.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    $str2
#   ^^^^^ variable.other.tcl

    string is ascii "my ascii"
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^ variable.function.string.tcl
#             ^^^^^ storage.type.tcl
#                   ^^^^^^^^^^ string.quoted.double.tcl

    string is inval "my ascii"
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^ variable.function.string.tcl
#             ^^^^^ - storage.type.tcl
#                   ^^^^^^^^^^ string.quoted.double.tcl

    string inval $str
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^ - variable.function.string.tcl
#                ^^^^ variable.other.tcl

    string match "patt[-[\]_A-z]r?n" $str
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^ variable.function.string.tcl
#                ^ punctuation.definition.string.begin.tcl
#                ^^^^^^^^^^^^^^^^^^^ string.quoted.double.tcl
#                     ^ punctuation.section.bracket.begin.tcl
#                     ^^^^^^^^^^ meta.bracket.tcl constant.other.placeholder.tcl
#                      ^ - punctuation.separator
#                        ^^ constant.character.escape.tcl
#                            ^  punctuation.separator.sequence.tcl
#                              ^ punctuation.section.bracket.begin.tcl
#                                ^ constant.other.placeholder.tcl
#                                  ^ punctuation.definition.string.end.tcl
#                                    ^^^^ variable.other.tcl

    string \
#   ^^^^^^ keyword.other.builtin.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    match \
#  ^ - variable.function
#   ^^^^^ variable.function.string.tcl
#        ^ - variable.function
#         ^ punctuation.separator.continuation.newline.tcl
    -nocase \
#   ^^^^^^^ variable.parameter.tcl
#           ^ punctuation.separator.continuation.newline.tcl
    "p\?a\*t\[t\]
#  ^ - string
#   ^ punctuation.definition.string.begin.tcl
#   ^^^^^^^^^^^^^^ string.quoted.double.tcl
#     ^^ constant.character.escape.other.tcl - constant.other.placeholder
#        ^^ constant.character.escape.other.tcl - constant.other.placeholder
#           ^^ constant.character.escape.other.tcl - punctuation
#              ^^ constant.character.escape.other.tcl - punctuation
    [_A-z]*r?n
#^^^^^^^^^^^^^^ string.quoted.double.tcl
#   ^ punctuation.section.bracket.begin.tcl
#        ^ punctuation.section.bracket.begin.tcl
#         ^ constant.other.placeholder.tcl
#           ^ constant.other.placeholder.tcl
    " $str
# <- string.quoted.double.tcl
#   ^ string.quoted.double.tcl punctuation.definition.string.end.tcl
#    ^ - string
#     ^^^^ variable.other.tcl

    string match -nocase {p\?a\*t\[t\][_A-z]*r?n} $str
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^ variable.function.string.tcl
#                ^^^^^^^ variable.parameter.tcl
#                        ^ punctuation.section.braces.begin.tcl
#                        ^^^^^^^^^^^^^^^^^^^^^^^^ meta.braces.tcl string.quoted.other.tcl
#                          ^^ constant.character.escape.other.tcl - constant.other.placeholder
#                             ^^ constant.character.escape.other.tcl - constant.other.placeholder
#                                ^^ constant.character.escape.other.tcl - punctuation
#                                   ^^ constant.character.escape.other.tcl - punctuation
#                                     ^ punctuation.section.bracket.begin.tcl
#                                          ^ punctuation.section.bracket.begin.tcl
#                                           ^ constant.other.placeholder.tcl
#                                             ^ constant.other.placeholder.tcl
#                                               ^ punctuation.section.braces.end.tcl

##############################################################################
# list commands
##############################################################################

    lappend listName value
