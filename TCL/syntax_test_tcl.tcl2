# SYNTAX TEST "TCL2.sublime-syntax"

##############################################################################
# [1] Commands
#
# A Tcl script is a string containing one or more commands. Semicolons and
# newlines are command separators unless quoted as described below. Close
# brackets are command terminators during command substitution unless quoted.
##############################################################################

    cmd arg1 arg2; cmd arg1 arg2
#  ^ - meta.function-call
#   ^^^^^^^^^^^^^ meta.function-call.tcl
#                ^ punctuation.terminator.command.tcl
#                 ^ - meta
#                  ^^^^^^^^^^^^^ meta.function-call.tcl
#  ^ - variable.function.tcl
#   ^^^ variable.function.tcl
#      ^ - variable.function.tcl

    cmd\
#   ^^^ variable.function.tcl
#      ^ punctuation.separator.continuation.newline.tcl
    arg1\
#   ^^^^ - variable.function
#       ^ punctuation.separator.continuation.newline.tcl
    arg2
#   ^^^^ - variable.function

    cmd \
#   ^^^ variable.function.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    arg1 \
#   ^^^^ - variable.function
#        ^ punctuation.separator.continuation.newline.tcl
    arg2
#   ^^^^ - variable.function

    cmd \; v]text [v]text
#       ^^ constant.character.escape.other.tcl
#           ^ - punctuation
#                 ^ punctuation.section.substitution.begin.tcl
#                 ^^^ meta.substitution.tcl
#                   ^ punctuation.section.substitution.end.tcl


    [cmd arg][cmd arg] {puts "str"}

    "cmd" arg arg

    {cmd} arg arg

    $cmd  arg arg

    ${cmd(test)} arg arg


##############################################################################
# [3] Words
#
# Words of a command are separated by white space
# (except for newlines, which are command separators).
##############################################################################


##############################################################################
# [4] Double quotes
#
# If the first character of a word is double quote (“"”) then the word is
# terminated by the next double quote character. Semicolons, close brackets,
# or white space characters (including newlines) are treated as ordinary
# characters and included in the word.
##############################################################################

    "foo } ] ; # bar \" \
#   ^ punctuation.definition.string.begin.tcl
#   ^^^^^^^^^^^^^^^^^ string.quoted.double.tcl
#        ^ - punctuation
#          ^ - punctuation
#            ^ - punctuation
#              ^ - punctuation
#              ^^^^^^^^ - comment
#                    ^^ constant.character.escape.other.tcl
#                       ^ - punctuation
    "
#^^^^ string.quoted.double.tcl
#   ^ punctuation.definition.string.end.tcl
#    - string - punctuation

# Command substitution, variable substitution, and backslash substitution are performed
    "$foo ${bar + 2} [baz]""invalid"
#  ^ - string - punctuation
#   ^ punctuation.definition.string.begin.tcl
#   ^^^^^^^^^^^^^^^^^^^^^^^ string.quoted.double.tcl
#    ^ punctuation.definition.variable.tcl
#    ^^^^ variable.other.tcl
#        ^ - variable.other
#         ^^ punctuation.definition.variable.begin.tcl
#         ^^^^^^^^^^ variable.other.tcl
#                  ^ punctuation.definition.variable.end.tcl
#                   ^ - variable.other
#                    ^ punctuation.section.substitution.begin.tcl
#                    ^^^^^ meta.substitution.tcl
#                        ^ punctuation.section.substitution.end.tcl
#                         ^ punctuation.definition.string.end.tcl
#                          ^ - string - punctuation
#                          ^^^^^^^^^ invalid.illegal.end-of-word-expected.tcl

# backslash substitution
    "foo $bar # baz ${bar + 2} [proc eval {}] \h \" "


##############################################################################
# [5] Argument expansion
#
# If a word starts with the string “{*}” followed by a non-whitespace character,
# then the leading “{*}” is removed and the rest of the word is parsed and
# substituted as any other word.
##############################################################################

    cmd a {*}{b [c]} d {*}{$e f {g h}} {*} {1 2 3}
#         ^^^ keyword.operator.word.tcl
#            ^ punctuation.section.braces.begin.tcl
#            ^^^^^^^ meta.braces.tcl - keyword.operator.word
#                  ^ punctuation.section.braces.end.tcl
#                         ^ punctuation.section.braces.begin.tcl
#                         ^^^^^^^^^^^^ meta.braces.tcl - keyword.operator.word
#                               ^ punctuation.section.braces.begin.tcl
#                               ^^^^^ meta.braces.tcl meta.braces.tcl
#                                   ^^ punctuation.section.braces.end.tcl
#                                      ^ punctuation.section.braces.begin.tcl
#                                      ^^^ meta.braces.tcl - keyword.operator.word
#                                        ^ punctuation.section.braces.end.tcl
#                                          ^ punctuation.section.braces.begin.tcl
#                                          ^^^^^^^ meta.braces.tcl - keyword.operator.word
#                                                ^ punctuation.section.braces.end.tcl


##############################################################################
# [6] Braces
#
# If the first character of a word is an open brace (“{”) and rule [5] does
# not apply, then the word is terminated by the matching close brace (“}”).
# Braces nest within the word: for each additional open brace there must be an
# additional close brace (however, if an open brace or close brace within the
# word is quoted with a backslash then it is not counted in locating the
# matching close brace). No substitutions are performed on the characters
# between the braces except for backslash-newline substitutions described
# below, nor do semi-colons, newlines, close brackets, or white space receive
# any special interpretation. The word will consist of exactly the characters
# between the outer braces, not including the braces themselves.
##############################################################################

    {}{
#  ^ - meta.braces - punctuation
#   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#    ^ meta.braces.tcl punctuation.section.braces.end.tcl
#     ^ invalid.illegal.end-of-word-expected.tcl - meta.braces - punctuation

    {
#  ^ - meta.braces - punctuation
#   ^ punctuation.section.braces.begin.tcl
#   ^^ meta.braces.tcl
    }{
#^^^^ meta.braces.tcl
#   ^ punctuation.section.braces.end.tcl
#    ^ invalid.illegal.end-of-word-expected.tcl - meta.braces - punctuation

    {;}
#  ^ - meta.braces
#   ^ punctuation.section.braces.begin.tcl
#   ^^^ meta.braces.tcl string.quoted.brace.tcl
#    ^ - punctuation
#     ^ punctuation.section.braces.end.tcl
#      ^ - meta.braces

    {puts} {test}
#  ^ - meta.braces
#   ^ punctuation.section.braces.begin.tcl
#   ^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#        ^ punctuation.section.braces.end.tcl
#         ^ - meta.braces
#          ^ punctuation.section.braces.begin.tcl
#          ^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#               ^ punctuation.section.braces.end.tcl

    {{{}{}}{}{}}
#   ^^^^^^^^^^^^ punctuation.section.braces - illegal


# ----------------------------------------------------------------------------
# https://github.com/SublimeTextIssues/DefaultPackages/issues/131

set ok1 {"}
#      ^ - meta.braces
#       ^ punctuation.section.braces.begin.tcl
#       ^^^ meta.braces.tcl string.quoted.brace.tcl
#        ^ - punctuation
#         ^ punctuation.section.braces.end.tcl
#          ^ - meta.braces
set ok2 {["]"]}
#      ^ - meta.braces
#       ^ punctuation.section.braces.begin.tcl
#       ^^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#        ^^^^^ - punctuation
#             ^ punctuation.section.braces.end.tcl
#              ^ - meta.braces
set ok3 {["][]"]}
#      ^ - meta.braces
#       ^ punctuation.section.braces.begin.tcl
#       ^^^^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#        ^^^^^^^ - punctuation
#               ^ punctuation.section.braces.end.tcl
#                ^ - meta.braces
set ok4 {["]["]}
#      ^ - meta.braces
#       ^ punctuation.section.braces.begin.tcl
#       ^^^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#        ^^^^^^ - punctuation
#              ^ punctuation.section.braces.end.tcl
#               ^ - meta.braces
set ok5 {["]["\"}"
#      ^ - meta.braces
#       ^ punctuation.section.braces.begin.tcl
#       ^^^^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#        ^^^^^^^ - punctuation
#               ^ punctuation.section.braces.end.tcl
#                ^ invalid.illegal.end-of-word-expected.tcl - meta.braces

# ----------------------------------------------------------------------------
# https://github.com/sublimehq/Packages/issues/783
# https://github.com/sublimehq/Packages/issues/784

set regexp {(^[a-zA-Z]{2}[a-zA-Z0-9-]{2,12}$)}
#         ^ - meta.braces
#          ^ punctuation.section.braces.begin.tcl
#          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.braces.tcl - invalid
#                                            ^ punctuation.section.braces.end.tcl
#                                             ^ - meta.braces
set regexp {(.{0,200})}
#         ^ - meta.braces
#          ^ punctuation.section.braces.begin.tcl
#          ^^^^^^^^^^^^ meta.braces.tcl - invalid
#                     ^ punctuation.section.braces.end.tcl
#                      ^ - meta.braces

##############################################################################
# [7] Command substitution
##############################################################################

    []
#  ^ - meta.substitution
#   ^^ meta.substitution.tcl
#   ^ punctuation.section.substitution.begin.tcl
#    ^ punctuation.section.substitution.end.tcl
#     ^ - meta.substitution

    [cmd a b][expr 1 + 5] arg arg
#  ^ - meta.substitution
#   ^ punctuation.section.substitution.begin.tcl
#   ^^^^^^^^^^^^^^^^^^^^^ meta.substitution.tcl
#           ^ punctuation.section.substitution.end.tcl
#            ^ punctuation.section.substitution.begin.tcl
#                       ^ punctuation.section.substitution.end.tcl
#                        ^ - meta.substitution.tcl
#                         ^^^ - keyword

    [
#  ^ - meta.substitution - punctuation
#   ^ punctuation.section.substitution.begin.tcl
#   ^^ meta.substitution.tcl
    ]
# <- meta.substitution.tcl
#^^^^ meta.substitution.tcl
#   ^ punctuation.section.substitution.end.tcl
#    ^ - meta.substitution - punctuation

    set y [set x 0][incr x][incr x]
#  ^ - meta
#        ^ - meta.substitution
#         ^^^^^^^^^^^^^^^^^^^^^^^^^ meta.substitution.tcl
#         ^ punctuation.section.substitution.begin.tcl
#                 ^ punctuation.section.substitution.end.tcl
#                  ^ punctuation.section.substitution.begin.tcl
#                         ^ punctuation.section.substitution.end.tcl
#                          ^ punctuation.section.substitution.begin.tcl
#                                 ^ punctuation.section.substitution.end.tcl
#                                  ^ - meta.substitution

    puts this_is_a_really_long_word[
#                                  ^ meta.substitution.tcl punctuation.section.substitution.begin.tcl
        ]_which_can't_have_spaces
#       ^ meta.substitution.tcl punctuation.section.substitution.end.tcl


# Command substitution is not performed on words enclosed in braces.
    set {bar [baz]}

    set saoid [svcmap_saoid sm]


##############################################################################
# [8] Variable substitution
#
# Name is the name of a scalar variable or array element. It may contain any
# characters whatsoever except for close braces. It indicates an array element
# if name is in the form “arrayName(index)” where arrayName does not contain
# any open parenthesis characters, “(”, or close brace characters, “}”, and
# index can be any sequence of characters except for close brace characters.
# No further substitutions are performed during the parsing of name.
##############################################################################

    cmd $var
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^ variable.other.tcl
#           ^ - variable.other

    cmd $var:novar
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^ variable.other.tcl
#           ^ - punctuation
#           ^^^^^^ - variable.other

    cmd pref$var[cmd arg]
#      ^^^^^ - variable.other
#           ^ punctuation.definition.variable.tcl
#           ^^^^ variable.other.tcl
#               ^ meta.substitution - variable.other

    cmd $ns::
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^^ variable.other.tcl
#          ^^ punctuation.accessor.colon.tcl
#            ^ - variable.other

    cmd $ns::var
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^^^^^ variable.other.tcl
#          ^^ punctuation.accessor.colon.tcl
#               ^ - variable.other

    cmd ${ns}::cmd
#      ^ - variable.other
#       ^^^^^ variable.other.tcl
#       ^^ punctuation.definition.variable.begin.tcl
#           ^ punctuation.definition.variable.end.tcl
#            ^^ punctuation.accessor.colon.tcl - variable.other

    cmd $var( arg , [set $var "x"] )
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ variable.other.tcl
#          ^ - meta.parens
#           ^ punctuation.section.parens.begin.tcl
#           ^^^^^^^^^^^^^^^^^^^^^^^^ meta.parens.tcl
#                 ^ punctuation.separator.sequence.tcl
#                   ^ punctuation.section.substitution.begin.tcl
#                   ^^^^^^^^^^^^^^ meta.substitution.tcl
#                    ^^^ keyword.other.builtin.tcl
#                        ^ punctuation.definition.variable.tcl
#                        ^^^^ variable.other.tcl variable.other.tcl
#                                ^ punctuation.section.substitution.end.tcl
#                                  ^ punctuation.section.parens.end.tcl
#                                   ^ - meta.parens - variable.other

    cmd $ns::var( arg , [set $var "x"] )
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ variable.other.tcl
#          ^^ punctuation.accessor.colon.tcl
#              ^ - meta.parens
#               ^ punctuation.section.parens.begin.tcl
#               ^^^^^^^^^^^^^^^^^^^^^^^^ meta.parens.tcl
#                     ^ punctuation.separator.sequence.tcl
#                       ^ punctuation.section.substitution.begin.tcl
#                       ^^^^^^^^^^^^^^ meta.substitution.tcl
#                        ^^^ keyword.other.builtin.tcl
#                            ^ punctuation.definition.variable.tcl
#                            ^^^^ variable.other.tcl variable.other.tcl
#                                    ^ punctuation.section.substitution.end.tcl
#                                      ^ punctuation.section.parens.end.tcl
#                                       ^ - meta.parens - variable.other

# Command substitutions, variable substitutions, and backslash substitutions
# are performed on the characters of index.

    cmd ${var-ia.b%le([set x 0], \U0B42[incr x]$idx)}
#      ^ - variable.other
#       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ variable.other.tcl
#       ^^ punctuation.definition.variable.begin.tcl
#                    ^ punctuation.section.parens.begin.tcl
#                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.parens.tcl
#                              ^ punctuation.separator.sequence.tcl
#                                                  ^ punctuation.section.parens.end.tcl
#                                                   ^ punctuation.definition.variable.end.tcl
#                                                    ^ - variable.other


# Variable substitution is not performed on words enclosed in braces.


    {$novar}

    {${name}}

    $name(idx1,idx2)

    ${arrayName(idx1,idx2)}


##############################################################################
# [9] Backslash substitution
##############################################################################

# Audible alert (bell) (0x7).
    \a
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Backspace (0x8).
    \b
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Form feed (0xc).
    \f
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Newline (0xa).
    \n
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Carriage-return (0xd).
    \r
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Tab (0x9).
    \t
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Vertical tab (0xb).
    \v
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Backslash
    \\
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Closing bracket
    \]
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Closing bracket
    \}
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Closing bracket
    \"
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Hashtag
    \#
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Eight-bit octal value for the Unicode character.
    \1
#  ^ - constant.character.escape
#   ^^ constant.character.escape.octal
#     ^ - constant.character.escape

    \19
#  ^ - constant.character.escape
#   ^^^ constant.character.escape.octal
#      ^ - constant.character.escape

    \152
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.octal
#       ^ - constant.character.escape

    \15232
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.octal
#       ^^^ - constant.character.escape

# Eight-bit hexadecimal value for the Unicode character.
# Any number of hexadecimal digits may be present; however, all but the last
# two are ignored (the result is always a one-byte quantity).
    \x
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

    \x1
#  ^ - constant.character.escape
#   ^^^ constant.character.escape.hexadecimal
#      ^ - constant.character.escape

    \x19
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.hexadecimal
#       ^ - constant.character.escape

    \x152
#  ^ - constant.character.escape
#   ^^^^^ constant.character.escape.hexadecimal
#        ^ - constant.character.escape

    \x1afbg
#  ^ - constant.character.escape
#   ^^^^^^ constant.character.escape.hexadecimal
#         ^^ - constant.character.escape

# A sixteen-bit hexadecimal value for the Unicode character
    \u
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

    \u0
#  ^ - constant.character.escape
#   ^^^ constant.character.escape.hexadecimal
#      ^ - constant.character.escape

    \u0a
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.hexadecimal
#       ^ - constant.character.escape

    \u0a5f
#  ^ - constant.character.escape
#   ^^^^^^ constant.character.escape.hexadecimal
#         ^ - constant.character.escape

    \u0ag
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.hexadecimal
#       ^ - constant.character.escape

    \u0a5fabcd
#  ^ - constant.character.escape
#   ^^^^^^ constant.character.escape.hexadecimal
#         ^^^^^ - constant.character.escape

# A thirty-two-bit hexadecimal value for the Unicode character
    \U
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

    \U0
#  ^ - constant.character.escape
#   ^^^ constant.character.escape.hexadecimal
#      ^ - constant.character.escape

    \U0a
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.hexadecimal
#       ^ - constant.character.escape

    \U0a5f
#  ^ - constant.character.escape
#   ^^^^^^ constant.character.escape.hexadecimal
#         ^ - constant.character.escape

    \U0a5g
#  ^ - constant.character.escape
#   ^^^^^ constant.character.escape.hexadecimal
#        ^ - constant.character.escape

    \U0a5fabcd
#  ^ - constant.character.escape
#   ^^^^^^^^^^ constant.character.escape.hexadecimal
#             ^ - constant.character.escape

    \U0a5fabcdddf
#  ^ - constant.character.escape
#   ^^^^^^^^^^ constant.character.escape.hexadecimal
#             ^^^^ - constant.character.escape


##############################################################################
# [10] Comments
#
# If a hash character (“#”) appears at a point where Tcl is expecting the
# first character of the first word of a command then the hash character and
# the characters that follow it, up through the next newline, are treated as a
# comment and ignored.
##############################################################################

    # command \
#  ^ - comment
#   ^ punctuation.definition.comment.begin.tcl
#   ^^^^^^^^^^^^ comment.line.double-dash.tcl
#             ^ - punctuation.separator.continuation.newline.tcl

    cmd#no comment
#      ^ - punctuation
#      ^^^^^^^^^^^^ - comment

    cmd # no comment
#       ^^^^^^^^^^^^^ - comment

    cmd;# no comment
#      ^ punctuation.terminator.command.tcl
#       ^ punctuation.definition.comment.begin.tcl
#       ^^^^^^^^^^^^^ comment.line.double-dash.tcl

    cmd ; # no comment
#       ^ punctuation.terminator.command.tcl
#         ^ punctuation.definition.comment.begin.tcl
#         ^^^^^^^^^^^^^ comment.line.double-dash.tcl

    cmd [# comment]
#       ^ punctuation.section.substitution.begin.tcl
#        ^ punctuation.definition.comment.begin.tcl
#        ^^^^^^^^^^^ comment.line.double-dash.tcl
#                 ^ - punctuation

        cmd [ set;# comment ];comment
#                ^ punctuation.terminator.command.tcl
#                 ^ punctuation.definition.comment.begin.tcl
#                 ^^^^^^^^^^^^^^^^^^^^ comment.line.double-dash.tcl
#                           ^^ - punctuation
            ]
#           ^ meta.substitution.tcl punctuation.section.substitution.end.tcl

        cmd [ set#no comment ]
#           ^ punctuation.section.substitution.begin.tcl
#                ^ - punctuation
#                ^^^^^^^^^^^^^^ - comment
#                            ^ punctuation.section.substitution.end.tcl

        cmd [ set # no comment ]
#           ^ punctuation.section.substitution.begin.tcl
#                 ^ - punctuation
#                 ^^^^^^^^^^^^^^^ - comment
#                              ^ punctuation.section.substitution.end.tcl
       ]
#      ^ punctuation.section.substitution.end.tcl

    set w { # no commet }
#           ^^^^^^^^^^^^^^ - comment

    set w { ; # no commet }
#             ^^^^^^^^^^^^^^ - comment

##############################################################################
# expr tests
##############################################################################

    expr
#  ^ - meta.expression
#   ^^^^^ meta.expression.tcl
#   ^^^^ keyword.other.builtin.tcl

    expr eq ne in ni == != <= >= < >
#        ^^ keyword.operator.relational.tcl
#           ^^ keyword.operator.relational.tcl
#              ^^ keyword.operator.relational.tcl
#                 ^^ keyword.operator.relational.tcl
#                    ^^ keyword.operator.relational.tcl
#                       ^^ keyword.operator.relational.tcl
#                          ^^ keyword.operator.relational.tcl
#                             ^^ keyword.operator.relational.tcl
#                                ^ keyword.operator.relational.tcl
#                                  ^ keyword.operator.relational.tcl

    expr && || !
#        ^^ keyword.operator.logical.tcl
#           ^^ keyword.operator.logical.tcl
#              ^ keyword.operator.logical.tcl

    expr ^ | & ~
#        ^ keyword.operator.bitwise.tcl
#          ^ keyword.operator.bitwise.tcl
#            ^ keyword.operator.bitwise.tcl
#              ^ keyword.operator.bitwise.tcl

    expr 1 + 2 * $var ** 4 % 2 / 1
#  ^ - meta.expression
#   ^^^^^^^^^^^^^^^^^^ meta.expression.tcl
#   ^^^^ keyword.other.builtin.tcl
#        ^ constant.numeric.integer.tcl
#          ^ keyword.operator.arithmetic.tcl
#            ^ constant.numeric.integer.tcl
#              ^ keyword.operator.arithmetic.tcl
#                ^^^^ variable.other.tcl
#                     ^^ keyword.operator.arithmetic.tcl
#                        ^ constant.numeric.integer.tcl
#                          ^ keyword.operator.arithmetic.tcl
#                            ^ constant.numeric.integer.tcl
#                              ^ keyword.operator.arithmetic.tcl
#                                ^ constant.numeric.integer.tcl

    expr $var ? "true" : "false"
#        ^^^^ variable.other.tcl
#             ^ keyword.operator.ternary.tcl
#               ^^^^^^ string.quoted.double.tcl
#                      ^ keyword.operator.ternary.tcl
#                        ^^^^^^^ string.quoted.double.tcl

    expr {}
#  ^ - meta.expression
#   ^^^^^^^^ meta.expression.tcl
#   ^^^^ keyword.other.builtin.tcl
#        ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#         ^ meta.braces.tcl punctuation.section.braces.end.tcl

    expr {
#  ^ - meta.expression
#   ^^^^^^^ meta.expression.tcl
#   ^^^^ keyword.other.builtin.tcl
#        ^ meta.braces.tcl punctuation.section.braces.begin.tcl
    } {
#^^^^^^^ meta.expression.tcl
#^^^^ meta.braces.tcl
#   ^ punctuation.section.braces.end.tcl
#    ^ - meta.braces
#     ^^ meta.braces.tcl
#     ^ punctuation.section.braces.begin.tcl
    }
#^^^^^ meta.expression.tcl
#^^^^ meta.braces.tcl
#   ^ punctuation.section.braces.end.tcl
#    ^ - meta.braces

    expr {
#  ^ - meta.expression
#   ^^^^^^^ meta.expression.tcl
#   ^^^^ keyword.other.builtin.tcl
#        ^ meta.braces.tcl punctuation.section.braces.begin.tcl
    list
#   ^^^^ - keyword - variable
    -
#^^^^^ meta.expression.tcl meta.braces.tcl
#   ^ keyword.operator.arithmetic.tcl
    $var
#^^^^^^^^ meta.expression.tcl meta.braces.tcl
#   ^^^^ variable.other.tcl
    +
#^^^^^ meta.expression.tcl meta.braces.tcl
#   ^ keyword.operator.arithmetic.tcl
    [string "test"]
#^^^ meta.expression.tcl meta.braces.tcl - meta.substitution
#   ^ punctuation.section.substitution.begin.tcl
#   ^^^^^^^^^^^^^^^ meta.expression.tcl meta.braces.tcl meta.substitution.tcl
#    ^^^^^^ keyword.other.builtin.tcl
#           ^^^^^^ string.quoted.double.tcl
#                 ^ punctuation.section.substitution.end.tcl
#                  ^ meta.expression.tcl meta.braces.tcl - meta.substitution
    *
#^^^^^ meta.expression.tcl meta.braces.tcl
#   ^ keyword.operator.arithmetic.tcl
    10
#^^^^^^ meta.expression.tcl meta.braces.tcl
#   ^^ constant.numeric.integer.tcl
    }
#^^^^^ meta.expression.tcl
#^^^^ meta.braces.tcl
#   ^ punctuation.section.braces.end.tcl

##############################################################################
# namespace tests
##############################################################################

    namespace
#   ^^^^^^^^^ keyword.other.builtin.tcl

    namespace children A
#   ^^^^^^^^^ keyword.other.builtin.tcl
#             ^^^^^^^^ variable.function.tcl

    namespace which -command "name"
#   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.namespace.tcl
#   ^^^^^^^^^ keyword.other.builtin.tcl
#             ^^^^^ variable.function.tcl
#                   ^^^^^^^^  variable.parameter.tcl
#                            ^^^^^^ string.quoted.double.tcl

    namespace $other
#   ^^^^^^^^^^^^^^^^^ meta.namespace.tcl
#   ^^^^^^^^^ keyword.other.builtin.tcl
#             ^^^^^^ variable.other.tcl

    namespace \
#   ^^^^^^^^^ keyword.other.builtin.tcl
#             ^ punctuation.separator.continuation.newline.tcl
    eval \
#   ^^^^ variable.function.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    A \
#   ^ entity.name.namespace.tcl
#     ^ punctuation.separator.continuation.newline.tcl
    {
#^^^ meta.namespace.tcl - meta.block
#   ^^ meta.namespace.tcl meta.block.tcl
#   ^ punctuation.section.block.begin.tcl
    }
#^^^^ meta.namespace.tcl meta.block.tcl
#    ^ meta.namespace.tcl - meta.block.tcl
#   ^ punctuation.section.block.end.tcl

    namespace eval A {
#  ^ - meta
#   ^^^^^^^^^^^^^^^^^^^ meta.namespace.tcl
#                    ^^ meta.block.tcl
#   ^^^^^^^^^ keyword.other.builtin.tcl
#             ^^^^ variable.function.tcl
#                  ^ entity.name.namespace.tcl
#                    ^ punctuation.section.block.begin.tcl
        namespace eval B \
#^^^^^^^ meta.namespace
#       ^^^^^^^^^^^^^^^^^^^ meta.namespace meta.namespace
#                    ^^ meta.block.tcl
#       ^^^^^^^^^ keyword.other.builtin.tcl
#                 ^^^^ variable.function.tcl
#                      ^ entity.name.namespace.tcl
#                        ^ punctuation.separator.continuation.newline
        {
#<- meta.namespace.tcl meta.namespace.tcl
#       ^ punctuation.section.block.begin.tcl
            namespace upvar $var
#           ^^^^^^^^^ keyword.other.builtin.tcl
#                     ^^^^^ storage.type.tcl
#                           ^^^^ variable.other.tcl
            namespace forget ns::var
#           ^^^^^^^^^ keyword.other.builtin.tcl
#                     ^^^^^^ variable.function.tcl

            proc A {

            }

            proc [proc A {}] {

            }

        }
    }

##############################################################################
# proc tests
##############################################################################

    proc
#   ^^^^ meta.function.tcl keyword.declaration.proc.tcl

    proc name
#  ^ - meta.function
#   ^^^^^^^^^^ meta.function.tcl
#   ^^^^ keyword.declaration.proc.tcl
#        ^^^^ entity.name.function.tcl
#            ^ - variable
    proc $name
#  ^ - meta.function
#   ^^^^^^^^^^ meta.function.tcl
#   ^^^^ keyword.declaration.proc.tcl
#        ^^^^^ variable.other.tcl
#             ^ - variable

    proc name args
#  ^ - meta.function
#   ^^^^^^^^^^^^^^^ meta.function.tcl
#             ^^^^ meta.function.parameters.tcl
#   ^^^^ keyword.declaration.proc.tcl
#        ^^^^ entity.name.function.tcl
#            ^ - variable
#             ^^^^ variable.parameter.tcl
#                 ^ - variable

    proc $name args
#  ^ - meta.function
#   ^^^^^^^^^^^^^^^ meta.function.tcl
#              ^^^^ meta.function.parameters.tcl
#   ^^^^ keyword.declaration.proc.tcl
#        ^^^^^ variable.other.tcl
#             ^ - variable
#              ^^^^ variable.parameter.tcl
#                  ^ - variable

    proc [expr name] args
#  ^ - meta.function
#   ^^^^^^^^^^^^^^^^^^^^^ meta.function.tcl
#                    ^^^^ meta.function.parameters.tcl
#   ^^^^ keyword.declaration.proc.tcl
#        ^^^^^^^^^^^ meta.substitution.tcl
#                   ^ - variable
#                    ^^^^ variable.parameter.tcl
#                        ^ - variable

    proc name args $body
#  ^ - meta.function
#   ^^^^^^^^^^^^^^^^^^^^^ meta.function.tcl
#             ^^^^ meta.function.parameters.tcl
#   ^^^^ keyword.declaration.proc.tcl
#        ^^^^ entity.name.function.tcl
#             ^^^^ variable.parameter.tcl
#                 ^ - variable
#                  ^^^^^ variable.other.tcl
#                       ^ - variable

    proc\
#  ^ - meta.function
#   ^^^^^^ meta.function.tcl
#   ^^^^ keyword.declaration.proc.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    name\
#^^^^^^^^^ meta.function.tcl
#   ^^^^ entity.name.function.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    args\
#^^^^^^^^^ meta.function.tcl
#   ^^^^ meta.function.parameters.tcl variable.parameter.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    $body
#^^^^^^^^ meta.function.tcl
#   ^^^^^ variable.other.tcl
#        ^ - variable

# If name includes any namespace qualifiers, the procedure is created in the specified namespace
    proc ns::name args $body
#  ^ - meta.function
#   ^^^^^^^^^^^^^^^^^^^^^^^^^ meta.function.tcl
#        ^^^^^^^^ entity.name.function.tcl
#          ^^ punctuation.accessor.colon.tcl
#                 ^^^^ meta.function.parameters.tcl
#                      ^^^^^ variable.other.tcl
#                           ^ - variable

# Args specifies the formal arguments to the procedure. It consists of a list,
# possibly empty, each of whose elements specifies one argument. Each argument
# specifier is also a list with either one or two fields. If there is only a
# single field in the specifier then it is the name of the argument; if there
# are two fields, then the first is the argument name and the second is its
# default value.
    proc name {} {}
#  ^ - meta.function
#   ^^^^^^^^^^^^^^^^ meta.function.tcl
#   ^^^^ keyword.declaration.proc.tcl
#        ^^^^ entity.name.function.tcl
#             ^ punctuation.section.braces.begin.tcl
#             ^^ meta.function.parameters.tcl meta.braces.tcl
#              ^ punctuation.section.braces.end.tcl
#                ^ punctuation.section.block.begin.tcl
#                ^^ meta.block.tcl
#                 ^ punctuation.section.block.end.tcl

    proc echo {{text "foo" invalid}} {puts $text}
#  ^ - meta.function
#   ^^^^^^^^^^ meta.function.tcl - meta.function.parameters - meta.braces
#             ^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl
#              ^^^^^^^^^^^^^^^^^^^^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl meta.braces.tcl
#                          ^^^^^^^ invalid.illegal.end-of-word-expected.tcl
#                                  ^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl
#                                   ^ meta.function.tcl - meta.function.parameters - meta.braces - meta.block
#                                    ^^^^^^^^^^^^ meta.block.tcl
#                                     ^^^^^^^^^^ meta.function-call.tcl
#   ^^^^ keyword.declaration.proc.tcl
#        ^^^^ entity.name.function.tcl
#             ^^ punctuation.section.braces.begin.tcl
#               ^^^^ variable.parameter.tcl
#                    ^^^^^ string.quoted.double.tcl
#                                 ^^ punctuation.section.braces.end.tcl
#                                    ^ punctuation.section.block.begin.tcl
#                                     ^^^^ keyword.other.builtin.tcl
#                                          ^^^^^ variable.other.tcl
#                                               ^ punctuation.section.block.end.tcl

    proc\
#  ^ - meta.function
#   ^^^^^^ meta.function.tcl - meta.function.parameters - meta.braces
#   ^^^^ keyword.declaration.proc.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    echo\
#  ^^^^^^^ meta.function.tcl - meta.function.parameters - meta.braces
#   ^^^^ entity.name.function.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    {\
#  ^ meta.function.tcl - meta.function.parameters - meta.braces
#   ^ punctuation.section.braces.begin.tcl
#   ^^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl
#    ^ punctuation.separator.continuation.newline.tcl
        {\
#      ^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl
#       ^ punctuation.section.braces.begin.tcl
#       ^^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl meta.braces.tcl
#        ^ punctuation.separator.continuation.newline.tcl
            text\
#           ^^^^ variable.parameter.tcl
#               ^ punctuation.separator.continuation.newline.tcl
            "foo"\
#           ^^^^^ string.quoted.double.tcl
#                ^ punctuation.separator.continuation.newline.tcl
            invalid\
#           ^^^^^^^ invalid.illegal.end-of-word-expected.tcl
#                  ^ punctuation.separator.continuation.newline.tcl
        }\
#      ^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl meta.braces.tcl - punctuation
#       ^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl meta.braces.tcl punctuation.section.braces.end.tcl
#        ^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl punctuation.separator.continuation.newline.tcl
    }\
#  ^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl - punctuation
#   ^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl punctuation.section.braces.end.tcl
#    ^ meta.function.tcl punctuation.separator.continuation.newline.tcl
    {
#   ^ meta.function.tcl meta.block.tcl punctuation.section.block.begin.tcl
        upvar var $up
#       ^^^^^^^^^^^^^^ meta.function.tcl meta.block.tcl meta.definition.variable.tcl
#       ^^^^^ storage.type.tcl
#             ^^^ variable.other.tcl
#                 ^^^ variable.other.tcl
        puts\
#       ^^^^ meta.function.tcl meta.block.tcl meta.function-call.tcl keyword.other.builtin.tcl
#           ^ meta.function.tcl meta.block.tcl meta.function-call.tcl punctuation.separator.continuation.newline.tcl
        $text
#       ^^^^^ meta.function.tcl meta.block.tcl meta.function-call.tcl variable.other.tcl
    }
#   ^ meta.function.tcl meta.block.tcl punctuation.section.block.end.tcl

    proc mult {par {multiplier 2}} {
#  ^ - meta.function
#   ^^^^^^^^^^ meta.function.tcl - meta.function.parameters - meta.braces
#             ^^^^^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl
#                  ^^^^^^^^^^^^^^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl meta.braces.tcl
#                                ^ meta.function.tcl meta.function.parameters.tcl meta.braces.tcl
#                                 ^ meta.function.tcl - meta.function.parameters - meta.braces
#                                  ^ meta.function.tcl meta.block.tcl punctuation.section.block.begin.tcl
#             ^ punctuation.section.braces.begin.tcl
#              ^^^ variable.parameter.tcl
#                  ^ punctuation.section.braces.begin.tcl
#                   ^^^^^^^^^^ variable.parameter.tcl
#                              ^ constant.numeric.integer.tcl
#                               ^^ punctuation.section.braces.end.tcl
#
        upvar 1 $par var
#<- meta.function.tcl meta.block.tcl
#       ^^^^^ meta.function.tcl meta.block.tcl meta.definition.variable.tcl storage.type.tcl
        set var [expr {$var * $multiplier}]
    } invalid
#<- meta.function.tcl meta.block.tcl
#^^^^ meta.function.tcl meta.block.tcl
#   ^ punctuation.section.block.end.tcl
#    ^^^^^^^^^ meta.function.tcl - meta.block.tcl
#     ^^^^^^^ invalid.illegal.end-of-cmd-expected.tcl

##############################################################################
# flow control keyword tests
##############################################################################

    break invalid ; # comment
#   ^^^^^ keyword.control.flow.break.tcl
#        ^ - keyword - invalid
#         ^^^^^^^ invalid.illegal.end-of-cmd-expected.tcl
#                ^ - invalid
#                 ^ punctuation.terminator.command.tcl
#                   ^ comment.line.double-dash.tcl

    break-me
#   ^^^^^ - keyword.control.flow

    break[incr x]
#   ^^^^^ - keyword.control.flow

    break(5)
#   ^^^^^ - keyword.control.flow

    continue "test";# comment
#   ^^^^^^^^ keyword.control.flow.continue.tcl
#           ^ - keyword - invalid
#            ^^^^^^ invalid.illegal.end-of-cmd-expected.tcl
#                  ^ punctuation.terminator.command.tcl
#                   ^ comment.line.double-dash.tcl

    continue-me
#   ^^^^^^^^ - keyword.control.flow

    continue[incr x]
#   ^^^^^^^^ - keyword.control.flow

    continue(2)
#   ^^^^^^^^ - keyword.control.flow

    exit

    return
#  ^ - keyword
#   ^^^^^^ keyword.control.flow.return.tcl
#         ^ - keyword
    returnme
#   ^^^^^^^^^ - keyword.control.flow

    return(1)
#   ^^^^^^^^^ - keyword.control.flow

    return 1
#  ^ - keyword
#   ^^^^^^ keyword.control.flow.return.tcl
#         ^ - keyword
#          ^ constant.numeric.integer.tcl

    return -code $code $factor
#  ^ - keyword
#   ^^^^^^ keyword.control.flow.return.tcl
#         ^ - keyword
#          ^^^^^ variable.parameter.tcl
#                ^^^^^ variable.other.tcl
#                      ^^^^^^^ variable.other.tcl

    return -code error \
#  ^ - keyword
#   ^^^^^^ keyword.control.flow.return.tcl
#         ^ - keyword
#          ^^^^^ variable.parameter.tcl
#                ^^^^^ constant.language.tcl
        "overflow computing factorial of $n"
#       ^ string.quoted.double.tcl punctuation.definition.string.begin.tcl

##############################################################################
# if-else tests
##############################################################################

    if true {} elseif false {} else {} ; if false {cmd arg}
#   ^^ keyword.control.flow.if.tcl
#      ^^^^ constant.language.tcl
#           ^ meta.block.tcl punctuation.section.block.begin.tcl
#            ^ meta.block.tcl punctuation.section.block.end.tcl
#              ^^^^^^ keyword.control.flow.elseif.tcl
#                     ^^^^^ constant.language.tcl
#                           ^ meta.block.tcl punctuation.section.block.begin.tcl
#                            ^ meta.block.tcl punctuation.section.block.end.tcl
#                              ^^^^ keyword.control.flow.else.tcl
#                                   ^ meta.block.tcl punctuation.section.block.begin.tcl
#                                    ^ meta.block.tcl punctuation.section.block.end.tcl
#                                      ^ punctuation.terminator.command.tcl
#                                        ^^ keyword.control.flow.if.tcl
#                                           ^^^^^ constant.language.tcl
#                                                 ^ punctuation.section.block.begin.tcl
#                                                 ^^^^^^^^^ meta.block.tcl
#                                                         ^ punctuation.section.block.end.tcl

# check line continuation as word break without preceding whitespace
    if\
#   ^^ keyword.control.flow.if.tcl
#     ^ punctuation.separator.continuation.newline.tcl
    true\
#   ^^^^ constant.language.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    {cmd arg arg}\
#   ^ punctuation.section.block.begin.tcl
#   ^^^^^^^^^^^^^ meta.block.tcl
#    ^^^ variable.function.tcl
#               ^ punctuation.section.block.end.tcl
#                ^ punctuation.separator.continuation.newline.tcl
    elseif\
#   ^^^^^^ keyword.control.flow.elseif.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    false\
#   ^^^^^ constant.language.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    {}\
#   ^ meta.block.tcl punctuation.section.block.begin.tcl
#    ^ meta.block.tcl punctuation.section.block.end.tcl
#     ^ punctuation.separator.continuation.newline.tcl
    elseif\
#   ^^^^^^ keyword.control.flow.elseif.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    [puts\
#   ^ punctuation.section.substitution.begin.tcl
#   ^^^^^^^^ meta.substitution.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    "true"]\
# <- meta.substitution.tcl
#^^^^^^^^^^ meta.substitution.tcl
#   ^^^^^^ string.quoted.double.tcl
#         ^ punctuation.section.substitution.end.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    {}\
#   ^ meta.block.tcl punctuation.section.block.begin.tcl
#    ^ meta.block.tcl punctuation.section.block.end.tcl
#     ^ punctuation.separator.continuation.newline.tcl
    else\
#   ^^^^ keyword.control.flow.else.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    {}
#   ^ meta.block.tcl punctuation.section.block.begin.tcl
#    ^ meta.block.tcl punctuation.section.block.end.tcl

# check line continuation with preceding whitespace
    if \
#   ^^ keyword.control.flow.if.tcl
#      ^ punctuation.separator.continuation.newline.tcl
    true \
#   ^^^^ constant.language.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    {cmd arg arg} \
#   ^ punctuation.section.block.begin.tcl
#   ^^^^^^^^^^^^^ meta.block.tcl
#    ^^^ variable.function.tcl
#               ^ punctuation.section.block.end.tcl
#                 ^ punctuation.separator.continuation.newline.tcl
    elseif \
#   ^^^^^^ keyword.control.flow.elseif.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    false \
#   ^^^^^ constant.language.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    {} \
#   ^ meta.block.tcl punctuation.section.block.begin.tcl
#    ^ meta.block.tcl punctuation.section.block.end.tcl
#      ^ punctuation.separator.continuation.newline.tcl
    elseif \
#   ^^^^^^ keyword.control.flow.elseif.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    [puts \
#   ^ punctuation.section.substitution.begin.tcl
#   ^^^^^^^^ meta.substitution.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    "true"] \
# <- meta.substitution.tcl
#^^^^^^^^^^ meta.substitution.tcl
#   ^^^^^^ string.quoted.double.tcl
#         ^ punctuation.section.substitution.end.tcl
#           ^ punctuation.separator.continuation.newline.tcl
    {} \
#   ^ meta.block.tcl punctuation.section.block.begin.tcl
#    ^ meta.block.tcl punctuation.section.block.end.tcl
#      ^ punctuation.separator.continuation.newline.tcl
    else \
#   ^^^^ keyword.control.flow.else.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    {}
#   ^ meta.block.tcl punctuation.section.block.begin.tcl
#    ^ meta.block.tcl punctuation.section.block.end.tcl

# Ensure else doesn't work outside of if command
    elseif true {}
#   ^^^^^^ invalid.illegal.unexpected.tcl
#          ^^^^ constant.language.tcl
#               ^ meta.block.tcl punctuation.section.block.begin.tcl
#                ^ meta.block.tcl punctuation.section.block.end.tcl
    elseif true {}
#   ^^^^^^ invalid.illegal.unexpected.tcl
#          ^^^^ constant.language.tcl
#               ^ meta.block.tcl punctuation.section.block.begin.tcl
#                ^ meta.block.tcl punctuation.section.block.end.tcl
    else {}
#   ^^^^ invalid.illegal.unexpected.tcl
#        ^ meta.block.tcl punctuation.section.block.begin.tcl
#         ^ meta.block.tcl punctuation.section.block.end.tcl
    else {}
#   ^^^^ invalid.illegal.unexpected.tcl
#        ^ meta.block.tcl punctuation.section.block.begin.tcl
#         ^ meta.block.tcl punctuation.section.block.end.tcl

    if {$arg eq [set x]} {
#   ^^ keyword.control.flow.if.tcl
#      ^ punctuation.section.braces.begin.tcl
#      ^^^^^^^^^^^^^^^^^ meta.braces.tcl
#       ^^^^ variable.other.tcl
#            ^^ keyword.operator.relational.tcl
#               ^^^^^^^ meta.substitution.tcl
#                      ^ punctuation.section.braces.end.tcl
#                        ^^ meta.block.tcl
#                        ^ punctuation.section.block.begin.tcl
        set var 0

        if {$var == 0} {
            puts "bar"
        } else {
            puts "baz"
        }

    } elseif [puts "true"] {

        puts "foo"
    } else {
        puts "bar"
    }

    if {[catch {ns::func -class interface \
#   ^^^ meta.statement.conditional.tcl
#      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl
#   ^^ keyword.control.flow.if.tcl
#      ^ punctuation.section.braces.begin.tcl
#       ^ punctuation.section.substitution.begin.tcl
#        ^^^^^ keyword.control.flow.catch.tcl
#              ^ punctuation.section.block.begin.tcl
#               ^^^^^^^^ meta.command.tcl variable.function.tcl
#                 ^^ punctuation.accessor.colon.tcl
#                        ^^^^^^ variable.parameter.tcl
#                                         ^ punctuation.separator.continuation.newline.tcl
        -flags "statistics,interfaceautoprobe" \
#<- meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.block.tcl
#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.block.tcl
#       ^^^^^^ variable.parameter.tcl
#              ^ punctuation.definition.string.begin.tcl
#              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string.quoted.double.tcl
#                         ^ - punctuation
#                                            ^ punctuation.definition.string.end.tcl
#                                              ^ punctuation.separator.continuation.newline.tcl
        -name $aggrname -role $extra_role \
#<- meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.block.tcl
#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.block.tcl
#       ^^^^^ variable.parameter.tcl
#             ^^^^^^^^^ variable.other.tcl
#                       ^^^^^ variable.parameter.tcl
#                             ^^^^^^^^^^^ variable.other.tcl
#                                         ^ punctuation.separator.continuation.newline.tcl
                        -parameters [array get params] \
#<- meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.block.tcl
#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.block.tcl
#                       ^^^^^^^^^^^ variable.parameter.tcl
#                                   ^ punctuation.section.substitution.begin.tcl
#                                   ^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.block.tcl meta.substitution.tcl
#                                    ^^^^^ keyword.other.builtin.tcl
#                                                    ^ punctuation.section.substitution.end.tcl
#                                                      ^ punctuation.separator.continuation.newline.tcl
        -opaque [list "becs.editor" "ifrole.tcl"] \
#<- meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.block.tcl
#^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.block.tcl
#       ^^^^^^^ variable.parameter.tcl
#               ^ punctuation.section.substitution.begin.tcl
#               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.block.tcl meta.substitution.tcl
#                ^^^^ keyword.other.builtin.tcl
#                     ^ punctuation.definition.string.begin.tcl
#                     ^^^^^^^^^^^^^ string.quoted.double.tcl
#                          ^ - punctuation
#                                 ^ punctuation.definition.string.end.tcl
#                                  ^ - string
#                                   ^ punctuation.definition.string.begin.tcl
#                                   ^^^^^^^^^^^^ string.quoted.double.tcl
#                                        ^ - punctuation
#                                              ^ punctuation.definition.string.end.tcl
#                                               ^ punctuation.section.substitution.end.tcl
#                                                 ^ punctuation.separator.continuation.newline.tcl
        -parentoid $aggr_attach_oid} err]} {
#<- meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.block.tcl
#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.block.tcl
#       ^^^^^^^^^^ variable.parameter.tcl
#                  ^^^^^^^^^^^^^^^^ variable.other.tcl
#                                  ^ punctuation.section.block.end.tcl
#                                   ^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl
#                                    ^^^ variable.other.tcl
#                                       ^ punctuation.section.substitution.end.tcl
#                                        ^ meta.statement.conditional.tcl meta.braces.tcl punctuation.section.braces.end.tcl - meta.substitution
#                                         ^ meta.statement.conditional.tcl - meta.braces - meta.substitution - punctuation
#                                          ^ meta.statement.conditional.tcl meta.block.tcl punctuation.section.block.begin.tcl
        return "Creating aggregator interface $aggrname under element/management element-module OID $aggr_attach_oid: $err"
#<- meta.statement.conditional.tcl meta.block.tcl
    }
#   ^ meta.statement.conditional.tcl meta.block.tcl punctuation.section.block.end.tcl

##############################################################################
# for loop tests
##############################################################################


    # for loop execution
    for {set a 10} {$a < 20} {incr a} {
#   ^^^ keyword.control.flow.for.tcl
#       ^ punctuation.section.block.begin.tcl
#       ^^^^^^^^^^ meta.block.tcl
#        ^^^ keyword.other.builtin.tcl
#            ^ variable.other.tcl
#              ^^ constant.numeric.integer.tcl
#                ^ punctuation.section.block.end.tcl
#                 ^ - meta.block - meta.braces
#                  ^ punctuation.section.braces.begin.tcl
#                  ^^^^^^^^^ meta.braces.tcl
#                   ^^ variable.other.tcl
#                      ^ keyword.operator.relational.tcl
#                        ^^ constant.numeric.integer.tcl
#                          ^ punctuation.section.braces.end.tcl
#                           ^ - meta.block - meta.braces
#                            ^ punctuation.section.block.begin.tcl
#                            ^^^^^^^^ meta.block.tcl
#                             ^^^^ keyword.other.builtin.tcl
#                                  ^ variable.other.tcl
#                                   ^ punctuation.section.block.end.tcl
#                                    ^ - meta.block - meta.braces
#                                     ^ punctuation.section.block.begin.tcl
#                                     ^^ meta.block.tcl
#
       puts "value of a: $a"
    }


    foreach i {
       GigabitEthernet1/18
       Serial2/2/0.1/2/1/1:0
       Serial2/2/0.1/2/1/2:0
       Serial2/2/0.1/2/1/3:0
       Serial2/2/0.1/2/2/1:0
       Serial2/2/0.1/2/2/2:0
       Serial2/2/0.1/2/2/3:0
       GigabitEthernet9/24
    } {
        set int [exec "show run inter $i | in Serial"]
        if {[regexp "Serial" $int ]} {
            puts "interface $i"
            puts "encap ppp"
        } else {
           puts "interface $i"
           puts "cdp enable"
           puts "Dampening"
           puts "no sh"
        }
    }

##############################################################################
# array commands
##############################################################################

    array set cpe_param [objectGetField -oid $cpeoid -fieldname parameters]
#   ^^^^^ keyword.other.builtin.tcl
#         ^^^ variable.function.tcl
#             ^^^^^^^^^ variable.other.tcl
#                       ^ punctuation.section.substitution.begin.tcl
#                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.substitution.tcl
#                                                                         ^ punctuation.section.substitution.end.tcl

    array names list_name -glob "pa?[A-z]ttern"
#   ^^^^^ keyword.other.builtin.tcl
#        ^ - keyword - variable
#         ^^^^^ variable.function.tcl
#              ^ - variable
#               ^^^^^^^^^ variable.other.tcl
#                        ^ - variable
#                         ^^^^^ variable.parameter.tcl
#                              ^ - variable - string
#                               ^ punctuation.definition.string.begin.tcl
#                               ^^^^^^^^^^^^^^^ string.quoted.double.tcl
#                                  ^ constant.other.placeholder.tcl
#                                   ^^^^^ meta.bracket.tcl constant.other.placeholder.tcl
#                                             ^ punctuation.definition.string.end.tcl
#                                              ^ - string

    array\
#   ^^^^^ keyword.other.builtin.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    names\
#   ^^^^^ variable.function.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    list_name\
#   ^^^^^^^^^ variable.other.tcl
#            ^ punctuation.separator.continuation.newline.tcl
    -glob\
#   ^^^^^ variable.parameter.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    "pa?[A-z]ttern"
#  ^ - variable - string
#   ^ punctuation.definition.string.begin.tcl
#   ^^^^^^^^^^^^^^^ string.quoted.double.tcl
#      ^ constant.other.placeholder.tcl
#       ^^^^^ meta.bracket.tcl constant.other.placeholder.tcl
#                 ^ punctuation.definition.string.end.tcl
#                  ^ - string

    array \
#   ^^^^^ keyword.other.builtin.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    names \
#   ^^^^^ variable.function.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    list_name \
#   ^^^^^^^^^ variable.other.tcl
#             ^ punctuation.separator.continuation.newline.tcl
    -glob \
#   ^^^^^ variable.parameter.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    "pa?[A-z]ttern"
#  ^ - variable - string
#   ^ punctuation.definition.string.begin.tcl
#   ^^^^^^^^^^^^^^^ string.quoted.double.tcl
#      ^ constant.other.placeholder.tcl
#       ^^^^^ meta.bracket.tcl constant.other.placeholder.tcl
#                 ^ punctuation.definition.string.end.tcl
#                  ^ - string

##############################################################################
# after commands
##############################################################################

    set id [after 10 [puts "done!"]]
#           ^^^^^ keyword.other.builtin.tcl

    after cancel $id
#   ^^^^^ keyword.other.builtin.tcl
#         ^^^^^^ constant.language.tcl
#                ^^^ variable.other.tcl

    after\
#   ^^^^^ keyword.other.builtin.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    cancel\
#   ^^^^^^ constant.language.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    $id
#   ^^^ variable.other.tcl

    after info $id
#   ^^^^^ keyword.other.builtin.tcl
#         ^^^^ constant.language.tcl
#              ^^^ variable.other.tcl

    after idle [list after 0 doOneStep]
#   ^^^^^ keyword.other.builtin.tcl
#         ^^^^ constant.language.tcl
#              ^^^^^^^^^^^^^^^^^^^^^^^^ meta.substitution.tcl

    after\
#   ^^^^^ keyword.other.builtin.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    $event\
#   ^^^^^^ variable.other.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    $id
#   ^^^ variable.other.tcl

##############################################################################
# incr commands
##############################################################################

    incr
#   ^^^^ keyword.other.builtin.tcl

    incr var
#   ^^^^ keyword.other.builtin.tcl
#        ^^^ variable.other.tcl

    incr var 2 illegal
#   ^^^^ keyword.other.builtin.tcl
#        ^^^ variable.other.tcl
#           ^ - variable - constant
#            ^ constant.numeric.integer.tcl - variable
#              ^^^^^^^ invalid.illegal.end-of-cmd-expected.tcl

##############################################################################
# regexp commands
##############################################################################

    regexp -start 5 {\mfoo(?!bar\M)(\w*)} $string -> restOfWord
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^^ variable.parameter.regexp.tcl
#                 ^ constant.numeric.integer.tcl
#                   ^ punctuation.section.braces.begin.tcl
#                   ^^^^^^^^^^^^^^^^^^^^^ meta.braces.tcl string.quoted.brace.tcl string.regexp.tcl
#                                       ^ punctuation.section.braces.end.tcl
#                                         ^^^^^^^ variable.other.tcl
#                                                 ^^ variable.other

# https://github.com/sublimehq/Packages/issues/779
    regexp -inline -all -- {%[a-zA-Z_]*%} "whatever"
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^^^ variable.parameter.regexp.tcl
#                 ^ - punctuation - variable
#                  ^^^^ variable.parameter.regexp.tcl
#                      ^ - punctuation - variable
#                       ^^ punctuation.terminator.switches.tcl
#                         ^ - meta.braces - punctuation - string
#                          ^ punctuation.section.braces.begin.tcl
#                          ^^^^^^^^^^^^^^ meta.braces.tcl string.quoted.brace.tcl string.regexp.tcl
#                                       ^ punctuation.section.braces.end.tcl
#                                        ^ - meta.braces - string
#                                         ^^^^^^^^^^ string.quoted.double.tcl
    regexp\
#   ^^^^^^ keyword.other.builtin.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    -inline\
#   ^^^^^^^ variable.parameter.regexp.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    -all\
#   ^^^^ variable.parameter.regexp.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    --\
#   ^^ punctuation.terminator.switches.tcl
#     ^ punctuation.separator.continuation.newline.tcl
    {%[a-zA-Z_]*%}\
#  ^ - meta.braces - punctuation - string
#   ^ punctuation.section.braces.begin.tcl
#   ^^^^^^^^^^^^^^ meta.braces.tcl string.quoted.brace.tcl string.regexp.tcl
#                ^ punctuation.section.braces.end.tcl
#                 ^ punctuation.separator.continuation.newline.tcl
    "whatever"
#  ^ - meta.braces - string
#   ^^^^^^^^^^ string.quoted.double.tcl

    regexp {instance="?([^" \t]+)"?} $counter matchedstring instance; # comment
#   ^^^^^^ keyword.other.builtin.tcl
#         ^ - keyword - meta.braces - string
#          ^ punctuation.section.braces.begin.tcl
#          ^^^^^^^^^^^^^^^^^^^^^^^^^ meta.braces.tcl
#           ^^^^^^^^^^^^^^^^^^^^^^^ string.regexp
#                                  ^ punctuation.section.braces.end.tcl
#                                   ^ - meta.braces - string
#                                    ^^^^^^^^ variable.other.tcl
#                                             ^^^^^^^^^^^^^ variable.other.tcl
#                                                           ^^^^^^^^ variable.other.tcl
#                                                                   ^ punctuation.terminator.command.tcl
#                                                                     ^ comment.line.double-dash.tcl punctuation.definition.comment.begin.tcl

    regsub
#   ^^^^^^ keyword.other.builtin.tcl

    regsub ; regexp;#
#   ^^^^^^ keyword.other.builtin.tcl
#          ^ punctuation.terminator.command.tcl
#            ^^^^^^ keyword.other.builtin.tcl
#                  ^ punctuation.terminator.command.tcl
#                   ^ comment.line.double-dash.tcl punctuation.definition.comment.begin.tcl

    regsub -all {"} $args {""}
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^ variable.parameter.regexp.tcl
#              ^ - meta.braces - constant - string - variable
#               ^ punctuation.section.braces.begin.tcl
#               ^^^ meta.braces.tcl string.quoted.brace.tcl string.regexp.tcl
#                 ^ punctuation.section.braces.end.tcl
#                  ^ - meta.braces - string
#                   ^ variable.other.tcl punctuation.definition.variable.tcl
#                    ^^^^ variable.other.tcl
#                        ^ - meta.braces - string - variable
#                         ^ punctuation.section.braces.begin.tcl
#                         ^^^^ meta.braces.tcl string.quoted.brace.tcl string.regexp.tcl
#                            ^ punctuation.section.braces.end.tcl
#                             ^ - meta.braces - string

    regsub -start 5 -all -- -all\b[set var] $var
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^^ variable.parameter.regexp.tcl
#                 ^ constant.numeric.integer.tcl
#                   ^^^^ variable.parameter.regexp.tcl
#                        ^^ punctuation.terminator.switches.tcl
#                           ^^^^^^^^^^^^^^^ string.unquoted.tcl string.regexp.tcl
#                                 ^ punctuation.section.substitution.begin.tcl
#                                 ^^^^^^^^^ meta.substitution.tcl
#                                         ^ punctuation.section.substitution.end.tcl
#                                           ^^^^ variable.other.tcl

    regsub -all {[A-z]\d+na\/\b} $args {\\} varname illegal
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^ variable.parameter.regexp.tcl
#               ^ punctuation.section.braces.begin.tcl
#               ^^^^^^^^^^^^^^^^ meta.braces.tcl
#                              ^ punctuation.section.braces.end.tcl
#                                ^^^^^ variable.other.tcl
#                                      ^ punctuation.section.braces.begin.tcl
#                                      ^^^^ meta.braces.tcl
#                                         ^ punctuation.section.braces.end.tcl
#                                           ^^^^^^^ variable.other.tcl
#                                                   ^^^^^^^ invalid.illegal.end-of-cmd-expected.tcl

    regsub\
#   ^^^^^^ keyword.other.builtin.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    -all\
#   ^^^^ variable.parameter.regexp.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    {[A-z]\d+na\/\b}\
#   ^ punctuation.section.braces.begin.tcl
#   ^^^^^^^^^^^^^^^^ meta.braces.tcl
#                  ^ punctuation.section.braces.end.tcl
#                   ^ punctuation.separator.continuation.newline.tcl
    $args\
#   ^^^^^ variable.other.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    {\\}\
#   ^ punctuation.section.braces.begin.tcl
#   ^^^^ meta.braces.tcl
#      ^ punctuation.section.braces.end.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    varname\
#   ^^^^^^^ variable.other.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    illegal
#   ^^^^^^^ invalid.illegal.end-of-cmd-expected.tcl

    regsub -all "[A-z]\d+na\/\b" $args "\\" args
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^ variable.parameter.regexp.tcl
#               ^ punctuation.definition.string.begin.tcl
#               ^^^^^^^^^^^^^^^^ string.quoted.double.tcl string.regexp.tcl
#                              ^ punctuation.definition.string.end.tcl
#                                ^^^^^ variable.other.tcl
#                                      ^ punctuation.definition.string.begin.tcl
#                                      ^^^^ string.quoted.double.tcl string.regexp
#                                         ^ punctuation.definition.string.end.tcl

    regsub -- "${one_arg_opt_pattern}\\s+\\S+" $args {} args
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^ punctuation.terminator.switches.tcl
#             ^ string.quoted.double.tcl string.regexp.tcl punctuation.definition.string.begin.tcl
#                                              ^ variable.other.tcl punctuation.definition.variable.tcl

##############################################################################
# string commands
##############################################################################

    string compare $str1 $str2; string last $str3
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^^^ variable.function.string.tcl
#                  ^^^^^ variable.other.tcl
#                        ^^^^^ variable.other.tcl
#                             ^ punctuation.terminator.command.tcl
#                               ^^^^^^ keyword.other.builtin.tcl
#                                      ^^^^ variable.function.string.tcl
#                                           ^^^^^ variable.other.tcl

    string\
#   ^^^^^^ keyword.other.builtin.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    compare\
#   ^^^^^^^ variable.function.string.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    $str1\
#   ^^^^^ variable.other.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    $str2
#   ^^^^^ variable.other.tcl

    string \
#   ^^^^^^ keyword.other.builtin.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    compare \
#   ^^^^^^^ variable.function.string.tcl
#           ^ punctuation.separator.continuation.newline.tcl
    $str1 \
#   ^^^^^ variable.other.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    $str2
#   ^^^^^ variable.other.tcl

    string is ascii "my ascii"
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^ variable.function.string.tcl
#             ^^^^^ storage.type.tcl
#                   ^^^^^^^^^^ string.quoted.double.tcl

    string is inval "my ascii"
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^ variable.function.string.tcl
#             ^^^^^ - storage.type.tcl
#                   ^^^^^^^^^^ string.quoted.double.tcl

    string inval $str
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^ - variable.function.string.tcl
#                ^^^^ variable.other.tcl

    string match "patt[-[\]_A-z]r?n" $str
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^ variable.function.string.tcl
#                ^ punctuation.definition.string.begin.tcl
#                ^^^^^^^^^^^^^^^^^^^ string.quoted.double.tcl
#                     ^ punctuation.section.bracket.begin.tcl
#                     ^^^^^^^^^^ meta.bracket.tcl constant.other.placeholder.tcl
#                      ^ - punctuation.separator
#                        ^^ constant.character.escape.tcl
#                            ^  punctuation.separator.sequence.tcl
#                              ^ punctuation.section.bracket.begin.tcl
#                                ^ constant.other.placeholder.tcl
#                                  ^ punctuation.definition.string.end.tcl
#                                    ^^^^ variable.other.tcl

    string\
#   ^^^^^^ keyword.other.builtin.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    match\
#  ^ - variable.function
#   ^^^^^ variable.function.string.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    -nocase\
#   ^^^^^^^ variable.parameter.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    "patt[-[\]_A-z]r?n" $str
#   ^^^^^^^^^^^^^^^^^^^ string.quoted.double.tcl
#        ^ punctuation.section.bracket.begin.tcl
#        ^^^^^^^^^^ meta.bracket.tcl constant.other.placeholder.tcl
#         ^ - punctuation.separator
#           ^^ constant.character.escape.tcl
#               ^  punctuation.separator.sequence.tcl
#                 ^ punctuation.section.bracket.begin.tcl
#                   ^ constant.other.placeholder.tcl
#                     ^ punctuation.definition.string.end.tcl
#                       ^^^^ variable.other.tcl

    string \
#   ^^^^^^ keyword.other.builtin.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    match \
#  ^ - variable.function
#   ^^^^^ variable.function.string.tcl
#        ^ - variable.function
#         ^ punctuation.separator.continuation.newline.tcl
    -nocase \
#   ^^^^^^^ variable.parameter.tcl
#           ^ punctuation.separator.continuation.newline.tcl
    "p\?a\*t\[t\]
#  ^ - string
#   ^ punctuation.definition.string.begin.tcl
#   ^^^^^^^^^^^^^^ string.quoted.double.tcl
#     ^^ constant.character.escape.other.tcl - constant.other.placeholder
#        ^^ constant.character.escape.other.tcl - constant.other.placeholder
#           ^^ constant.character.escape.other.tcl - punctuation
#              ^^ constant.character.escape.other.tcl - punctuation
    [_A-z]*r?n
#^^^^^^^^^^^^^^ string.quoted.double.tcl
#   ^ punctuation.section.bracket.begin.tcl
#        ^ punctuation.section.bracket.begin.tcl
#         ^ constant.other.placeholder.tcl
#           ^ constant.other.placeholder.tcl
    " $str
# <- string.quoted.double.tcl
#   ^ string.quoted.double.tcl punctuation.definition.string.end.tcl
#    ^ - string
#     ^^^^ variable.other.tcl

    string match -nocase {p\?a\*t\[t\][_A-z]*r?n} $str
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^ variable.function.string.tcl
#                ^^^^^^^ variable.parameter.tcl
#                        ^ punctuation.section.braces.begin.tcl
#                        ^^^^^^^^^^^^^^^^^^^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#                          ^^ constant.character.escape.other.tcl - constant.other.placeholder
#                             ^^ constant.character.escape.other.tcl - constant.other.placeholder
#                                ^^ constant.character.escape.other.tcl - punctuation
#                                   ^^ constant.character.escape.other.tcl - punctuation
#                                     ^ punctuation.section.bracket.begin.tcl
#                                          ^ punctuation.section.bracket.begin.tcl
#                                           ^ constant.other.placeholder.tcl
#                                             ^ constant.other.placeholder.tcl
#                                               ^ punctuation.section.braces.end.tcl

##############################################################################
# list commands
##############################################################################

    lappend listName value

##############################################################################
# set commands
##############################################################################

    set var "val"
#  ^ - meta - keyword
#   ^^^ keyword.other.builtin.tcl
#      ^ - keyword - variable
#       ^^^ variable.other.tcl
#          ^ - variable - string
#           ^^^^^ string.quoted.double.tcl
#                ^ - string

    set\
#  ^ - meta - keyword
#   ^^^ keyword.other.builtin.tcl
#      ^ punctuation.separator.continuation.newline.tcl
    var\
#   ^^^ variable.other.tcl
#      ^ punctuation.separator.continuation.newline.tcl
    "val"
#   ^^^^^ string.quoted.double.tcl
#

    set var {val}
#  ^ - meta - keyword
#   ^^^ keyword.other.builtin.tcl
#      ^ - keyword - variable
#       ^^^ variable.other.tcl
#           ^^^^^ string.quoted.brace.tcl
#

    set {var1 var2} [list "val1" {val2}]
#  ^ - meta - keyword
#   ^^^ keyword.other.builtin.tcl
#      ^ - keyword - variable
#       ^ punctuation.section.braces.begin.tcl
#       ^^^^^^^^^^^ meta.braces.tcl
#        ^^^^ variable.other.tcl
#            ^ - variable
#             ^^^^ variable.other.tcl
#                 ^ punctuation.section.braces.end.tcl
#                  ^ - variable
#                   ^ punctuation.section.substitution.begin.tcl
#                   ^^^^^^^^^^^^^^^^^^^^ meta.substitution.tcl
#                    ^^^^ keyword.other.builtin.tcl
#                                      ^ punctuation.section.substitution.end.tcl

    set anAry(msg) "Hello, World!"
#  ^ - meta - keyword
#   ^^^ keyword.other.builtin.tcl
#      ^ - keyword - variable
#       ^^^^^^^^^^ variable.other.tcl
#            ^ punctuation.section.parens.begin.tcl
#            ^^^^^ meta.parens.tcl
#                ^ punctuation.section.parens.end.tcl

    set vbl in[expr {rand() >= 0.5}]

##############################################################################
# switch commands
##############################################################################

    switch -glob -- $var {
#   ^^^^^^ keyword.control.flow.switch.tcl
#          ^^^^^ variable.parameter.tcl
#                ^^ punctuation.terminator.switches.tcl
#                   ^^^^ variable.other.tcl
#                        ^^ meta.list.tcl
#                        ^ punctuation.section.list.begin.tcl
        label1 {
#<- meta.list.tcl
#       ^^^^^^ string.unquoted.tcl
#              ^^ meta.block.tcl
#              ^ punctuation.section.block.begin.tcl
            puts $var
#<- meta.list.tcl meta.block.tcl
#           ^^^^ meta.list.tcl meta.block.tcl meta.function-call.tcl keyword.other.builtin.tcl
        }
#<- meta.list.tcl meta.block.tcl
#       ^ meta.list.tcl meta.block.tcl punctuation.section.block.end.tcl
        label2 {
            puts "label 2"
        }
        "label 3" {puts "label 3"}
#<- meta.list.tcl
#       ^^^^^^^^^ string.quoted.double.tcl
#                 ^ punctuation.section.block.begin.tcl
#                 ^^^^^^^^^^^^^^^^ meta.list.tcl meta.block.tcl
#                                ^ punctuation.section.block.end.tcl
#                                 ^ meta.list.tcl - meta.block
#
    }
