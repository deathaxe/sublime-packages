# SYNTAX TEST "TCL2.sublime-syntax"

##############################################################################
# [1] Commands
#
# A Tcl script is a string containing one or more commands. Semicolons and
# newlines are command separators unless quoted as described below. Close
# brackets are command terminators during command substitution unless quoted.
##############################################################################

    cmd arg1 arg2; cmd arg1 arg2
#  ^ - meta.function-call
#   ^^^^^^^^^^^^^ meta.function-call.tcl
#                ^ punctuation.terminator.command.tcl
#                 ^ - meta
#                  ^^^^^^^^^^^^^ meta.function-call.tcl
    cmd\
#   ^^^ variable.function.tcl
#      ^ punctuation.separator.continuation.newline.tcl
    arg1\
#   ^^^^ - variable.function
#       ^ punctuation.separator.continuation.newline.tcl
    arg2
#   ^^^^ - variable.function

    cmd \
#   ^^^ variable.function.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    arg1 \
#   ^^^^ - variable.function
#        ^ punctuation.separator.continuation.newline.tcl
    arg2
#   ^^^^ - variable.function

    cmd \; v]text [v]text
#       ^^ constant.character.escape.other.tcl
#           ^ - punctuation
#                 ^ punctuation.section.substitution.begin.tcl
#                 ^^^ meta.substitution.tcl
#                   ^ punctuation.section.substitution.end.tcl


    [cmd arg][cmd arg] {puts "str"}

    "cmd" arg arg

    {cmd} arg arg

    $cmd  arg arg

    ${cmd(test)} arg arg


##############################################################################
# [3] Words
#
# Words of a command are separated by white space
# (except for newlines, which are command separators).
##############################################################################


##############################################################################
# [4] Double quotes
#
# If the first character of a word is double quote (“"”) then the word is
# terminated by the next double quote character. Semicolons, close brackets,
# or white space characters (including newlines) are treated as ordinary
# characters and included in the word.
##############################################################################

    "foo } ] ; # bar \" \
#   ^ punctuation.definition.string.begin.tcl
#   ^^^^^^^^^^^^^^^^^ string.quoted.double.tcl
#        ^ - punctuation
#          ^ - punctuation
#            ^ - punctuation
#              ^ - punctuation
#              ^^^^^^^^ - comment
#                    ^^ constant.character.escape.other.tcl
#                       ^ - punctuation
    "
#^^^^ string.quoted.double.tcl
#   ^ punctuation.definition.string.end.tcl
#    - string - punctuation

# Command substitution, variable substitution, and backslash substitution are performed
    "$foo ${bar + 2} [baz]""invalid"
#  ^ - string - punctuation
#   ^ punctuation.definition.string.begin.tcl
#   ^^^^^^^^^^^^^^^^^^^^^^^ string.quoted.double.tcl
#    ^ punctuation.definition.variable.tcl
#    ^^^^ variable.other.tcl
#        ^ - variable.other
#         ^^ punctuation.definition.variable.begin.tcl
#         ^^^^^^^^^^ variable.other.tcl
#                  ^ punctuation.definition.variable.end.tcl
#                   ^ - variable.other
#                    ^ punctuation.section.substitution.begin.tcl
#                    ^^^^^ meta.substitution.tcl
#                        ^ punctuation.section.substitution.end.tcl
#                         ^ punctuation.definition.string.end.tcl
#                          ^ - string - punctuation
#                          ^^^^^^^^^ invalid.illegal.end-of-word-expected.tcl

# backslash substitution
    "foo $bar # baz ${bar + 2} [proc eval {}] \h \" "


##############################################################################
# [5] Argument expansion
#
# If a word starts with the string “{*}” followed by a non-whitespace character,
# then the leading “{*}” is removed and the rest of the word is parsed and
# substituted as any other word.
##############################################################################

    cmd a {*}{b [c]} d {*}{$e f {g h}} {*} {1 2 3}
#         ^^^ keyword.operator.word.tcl
#            ^ punctuation.section.braces.begin.tcl
#            ^^^^^^^ meta.braces.tcl - keyword.operator.word
#                  ^ punctuation.section.braces.end.tcl
#                         ^ punctuation.section.braces.begin.tcl
#                         ^^^^^^^^^^^^ meta.braces.tcl - keyword.operator.word
#                               ^ punctuation.section.braces.begin.tcl
#                               ^^^^^ meta.braces.tcl meta.braces.tcl
#                                   ^^ punctuation.section.braces.end.tcl
#                                      ^ punctuation.section.braces.begin.tcl
#                                      ^^^ meta.braces.tcl - keyword.operator.word
#                                        ^ punctuation.section.braces.end.tcl
#                                          ^ punctuation.section.braces.begin.tcl
#                                          ^^^^^^^ meta.braces.tcl - keyword.operator.word
#                                                ^ punctuation.section.braces.end.tcl


##############################################################################
# [6] Braces
#
# If the first character of a word is an open brace (“{”) and rule [5] does
# not apply, then the word is terminated by the matching close brace (“}”).
# Braces nest within the word: for each additional open brace there must be an
# additional close brace (however, if an open brace or close brace within the
# word is quoted with a backslash then it is not counted in locating the
# matching close brace). No substitutions are performed on the characters
# between the braces except for backslash-newline substitutions described
# below, nor do semi-colons, newlines, close brackets, or white space receive
# any special interpretation. The word will consist of exactly the characters
# between the outer braces, not including the braces themselves.
##############################################################################

    {}{
#  ^ - meta.braces - punctuation
#   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#    ^ meta.braces.tcl punctuation.section.braces.end.tcl
#     ^ invalid.illegal.end-of-word-expected.tcl - meta.braces - punctuation

    {
#  ^ - meta.braces - punctuation
#   ^ punctuation.section.braces.begin.tcl
#   ^^ meta.braces.tcl
    }{
#^^^^ meta.braces.tcl
#   ^ punctuation.section.braces.end.tcl
#    ^ invalid.illegal.end-of-word-expected.tcl - meta.braces - punctuation

    {;}
#  ^ - meta.braces
#   ^ punctuation.section.braces.begin.tcl
#   ^^^ meta.braces.tcl string.quoted.brace.tcl
#    ^ - punctuation
#     ^ punctuation.section.braces.end.tcl
#      ^ - meta.braces

    {puts} {test}
#  ^ - meta.braces
#   ^ punctuation.section.braces.begin.tcl
#   ^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#        ^ punctuation.section.braces.end.tcl
#         ^ - meta.braces
#          ^ punctuation.section.braces.begin.tcl
#          ^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#               ^ punctuation.section.braces.end.tcl

    {{{}{}}{}{}}
#   ^^^^^^^^^^^^ punctuation.section.braces - illegal

    { {\} \{} \n \x10 ; ] $novar ${foo(bar,baz)} }
#  ^ - meta.braces - punctuation
#   ^ punctuation.section.braces.begin.tcl
#   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.braces.tcl
#     ^ punctuation.section.braces.begin.tcl
#     ^^^^^^^ meta.braces.tcl meta.braces.tcl
#      ^^ constant.character.escape.other.tcl - punctuation.section.braces
#         ^^ constant.character.escape.other.tcl - punctuation.section.braces
#           ^ punctuation.section.braces.end.tcl
#             ^^ constant.character.escape.other.tcl
#                ^^^^ - constant.character.escape
#                     ^ - punctuation
#                       ^ - punctuation
#                         ^^^^^^ - variable.other
#                                ^^^^^^^^^^^^^^^ - variable.other
#                                 ^ punctuation.section.braces.begin.tcl
#                                 ^^^^^^^^^^^^^^ meta.braces.tcl meta.braces.tcl
#                                     ^ - punctuation
#                                         ^ - punctuation
#                                             ^ - punctuation
#                                              ^ punctuation.section.braces.end.tcl
#                                                ^ punctuation.section.braces.end.tcl
#                                                 ^ - meta.braces - punctuation

# ----------------------------------------------------------------------------
# https://github.com/SublimeTextIssues/DefaultPackages/issues/131

set ok1 {"}
#      ^ - meta.braces
#       ^ punctuation.section.braces.begin.tcl
#       ^^^ meta.braces.tcl string.quoted.brace.tcl
#        ^ - punctuation
#         ^ punctuation.section.braces.end.tcl
#          ^ - meta.braces
set ok2 {["]"]}
#      ^ - meta.braces
#       ^ punctuation.section.braces.begin.tcl
#       ^^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#        ^^^^^ - punctuation
#             ^ punctuation.section.braces.end.tcl
#              ^ - meta.braces
set ok3 {["][]"]}
#      ^ - meta.braces
#       ^ punctuation.section.braces.begin.tcl
#       ^^^^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#        ^^^^^^^ - punctuation
#               ^ punctuation.section.braces.end.tcl
#                ^ - meta.braces
set ok4 {["]["]}
#      ^ - meta.braces
#       ^ punctuation.section.braces.begin.tcl
#       ^^^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#        ^^^^^^ - punctuation
#              ^ punctuation.section.braces.end.tcl
#               ^ - meta.braces
set ok5 {["]["\"}"
#      ^ - meta.braces
#       ^ punctuation.section.braces.begin.tcl
#       ^^^^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#        ^^^^^^^ - punctuation
#               ^ punctuation.section.braces.end.tcl
#                ^ invalid.illegal.end-of-word-expected.tcl - meta.braces

# ----------------------------------------------------------------------------
# https://github.com/sublimehq/Packages/issues/783
# https://github.com/sublimehq/Packages/issues/784

set regexp {(^[a-zA-Z]{2}[a-zA-Z0-9-]{2,12}$)}
#         ^ - meta.braces
#          ^ punctuation.section.braces.begin.tcl
#          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.braces.tcl - invalid
#                                            ^ punctuation.section.braces.end.tcl
#                                             ^ - meta.braces
set regexp {(.{0,200})}
#         ^ - meta.braces
#          ^ punctuation.section.braces.begin.tcl
#          ^^^^^^^^^^^^ meta.braces.tcl - invalid
#                     ^ punctuation.section.braces.end.tcl
#                      ^ - meta.braces

##############################################################################
# [7] Command substitution
##############################################################################

    []
#  ^ - meta.substitution
#   ^^ meta.substitution.tcl
#   ^ punctuation.section.substitution.begin.tcl
#    ^ punctuation.section.substitution.end.tcl
#     ^ - meta.substitution

    [cmd a b][expr 1 + 5] arg arg
#  ^ - meta.substitution
#   ^ punctuation.section.substitution.begin.tcl
#   ^^^^^^^^^^^^^^^^^^^^^ meta.substitution.tcl
#           ^ punctuation.section.substitution.end.tcl
#            ^ punctuation.section.substitution.begin.tcl
#                       ^ punctuation.section.substitution.end.tcl
#                        ^ - meta.substitution.tcl
#                         ^^^ - keyword

    [
#  ^ - meta.substitution - punctuation
#   ^ punctuation.section.substitution.begin.tcl
#   ^^ meta.substitution.tcl
      proc A {a b c} {

      }
    ]
# <- meta.substitution.tcl
#^^^^ meta.substitution.tcl
#   ^ punctuation.section.substitution.end.tcl
#    ^ - meta.substitution - punctuation

    set y [set x 0][incr x][incr x]
#  ^ - meta
#        ^ - meta.substitution
#         ^^^^^^^^^^^^^^^^^^^^^^^^^ meta.substitution.tcl
#         ^ punctuation.section.substitution.begin.tcl
#                 ^ punctuation.section.substitution.end.tcl
#                  ^ punctuation.section.substitution.begin.tcl
#                         ^ punctuation.section.substitution.end.tcl
#                          ^ punctuation.section.substitution.begin.tcl
#                                 ^ punctuation.section.substitution.end.tcl
#                                  ^ - meta.substitution

# Command substitution is not performed on words enclosed in braces.
    set {bar [baz]}

    set saoid [svcmap_saoid sm]


##############################################################################
# [8] Variable substitution
#
# Name is the name of a scalar variable or array element. It may contain any
# characters whatsoever except for close braces. It indicates an array element
# if name is in the form “arrayName(index)” where arrayName does not contain
# any open parenthesis characters, “(”, or close brace characters, “}”, and
# index can be any sequence of characters except for close brace characters.
# No further substitutions are performed during the parsing of name.
##############################################################################

    cmd $var
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^ variable.other.tcl
#           ^ - variable.other

    cmd $var:novar
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^ variable.other.tcl
#           ^ - punctuation
#           ^^^^^^ - variable.other

    cmd pref$var[cmd arg]
#      ^^^^^ - variable.other
#           ^ punctuation.definition.variable.tcl
#           ^^^^ variable.other.tcl
#               ^ meta.substitution - variable.other

    cmd $ns::
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^^ variable.other.tcl
#          ^^ punctuation.accessor.colon.tcl
#            ^ - variable.other

    cmd $ns::var
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^^^^^ variable.other.tcl
#          ^^ punctuation.accessor.colon.tcl
#               ^ - variable.other

    cmd ${ns}::cmd
#      ^ - variable.other
#       ^^^^^ variable.other.tcl
#       ^^ punctuation.definition.variable.begin.tcl
#           ^ punctuation.definition.variable.end.tcl
#            ^^ punctuation.accessor.colon.tcl - variable.other

    cmd $var( arg , [set $var "x"] )
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ variable.other.tcl
#          ^ - meta.parens
#           ^ punctuation.section.parens.begin.tcl
#           ^^^^^^^^^^^^^^^^^^^^^^^^ meta.parens.tcl
#                 ^ punctuation.separator.sequence.tcl
#                   ^ punctuation.section.substitution.begin.tcl
#                   ^^^^^^^^^^^^^^ meta.substitution.tcl
#                    ^^^ keyword.other.builtin.tcl
#                        ^ punctuation.definition.variable.tcl
#                        ^^^^ variable.other.tcl variable.other.tcl
#                                ^ punctuation.section.substitution.end.tcl
#                                  ^ punctuation.section.parens.end.tcl
#                                   ^ - meta.parens - variable.other

    cmd $ns::var( arg , [set $var "x"] )
#      ^ - variable.other
#       ^ punctuation.definition.variable.tcl
#       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ variable.other.tcl
#          ^^ punctuation.accessor.colon.tcl
#              ^ - meta.parens
#               ^ punctuation.section.parens.begin.tcl
#               ^^^^^^^^^^^^^^^^^^^^^^^^ meta.parens.tcl
#                     ^ punctuation.separator.sequence.tcl
#                       ^ punctuation.section.substitution.begin.tcl
#                       ^^^^^^^^^^^^^^ meta.substitution.tcl
#                        ^^^ keyword.other.builtin.tcl
#                            ^ punctuation.definition.variable.tcl
#                            ^^^^ variable.other.tcl variable.other.tcl
#                                    ^ punctuation.section.substitution.end.tcl
#                                      ^ punctuation.section.parens.end.tcl
#                                       ^ - meta.parens - variable.other

# Command substitutions, variable substitutions, and backslash substitutions
# are performed on the characters of index.

    cmd ${var-ia.b%le([set x 0], \U0B42[incr x]$idx)}
#      ^ - variable.other
#       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ variable.other.tcl
#       ^^ punctuation.definition.variable.begin.tcl
#                    ^ punctuation.section.parens.begin.tcl
#                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.parens.tcl
#                              ^ punctuation.separator.sequence.tcl
#                                                  ^ punctuation.section.parens.end.tcl
#                                                   ^ punctuation.definition.variable.end.tcl
#                                                    ^ - variable.other


# Variable substitution is not performed on words enclosed in braces.


    {$novar}

    {${name}}

    $name(idx1,idx2)

    ${arrayName(idx1,idx2)}


##############################################################################
# [9] Backslash substitution
##############################################################################

# Audible alert (bell) (0x7).
    \a
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Backspace (0x8).
    \b
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Form feed (0xc).
    \f
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Newline (0xa).
    \n
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Carriage-return (0xd).
    \r
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Tab (0x9).
    \t
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Vertical tab (0xb).
    \v
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Backslash
    \\
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Closing bracket
    \]
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Closing bracket
    \}
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Closing bracket
    \"
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Hashtag
    \#
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

# Eight-bit octal value for the Unicode character.
    \1
#  ^ - constant.character.escape
#   ^^ constant.character.escape.octal
#     ^ - constant.character.escape

    \19
#  ^ - constant.character.escape
#   ^^^ constant.character.escape.octal
#      ^ - constant.character.escape

    \152
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.octal
#       ^ - constant.character.escape

    \15232
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.octal
#       ^^^ - constant.character.escape

# Eight-bit hexadecimal value for the Unicode character.
# Any number of hexadecimal digits may be present; however, all but the last
# two are ignored (the result is always a one-byte quantity).
    \x
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

    \x1
#  ^ - constant.character.escape
#   ^^^ constant.character.escape.hexadecimal
#      ^ - constant.character.escape

    \x19
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.hexadecimal
#       ^ - constant.character.escape

    \x152
#  ^ - constant.character.escape
#   ^^^^^ constant.character.escape.hexadecimal
#        ^ - constant.character.escape

    \x1afbg
#  ^ - constant.character.escape
#   ^^^^^^ constant.character.escape.hexadecimal
#         ^^ - constant.character.escape

# A sixteen-bit hexadecimal value for the Unicode character
    \u
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

    \u0
#  ^ - constant.character.escape
#   ^^^ constant.character.escape.hexadecimal
#      ^ - constant.character.escape

    \u0a
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.hexadecimal
#       ^ - constant.character.escape

    \u0a5f
#  ^ - constant.character.escape
#   ^^^^^^ constant.character.escape.hexadecimal
#         ^ - constant.character.escape

    \u0ag
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.hexadecimal
#       ^ - constant.character.escape

    \u0a5fabcd
#  ^ - constant.character.escape
#   ^^^^^^ constant.character.escape.hexadecimal
#         ^^^^^ - constant.character.escape

# A thirty-two-bit hexadecimal value for the Unicode character
    \U
#  ^ - constant.character.escape
#   ^^ constant.character.escape.other
#     ^ - constant.character.escape

    \U0
#  ^ - constant.character.escape
#   ^^^ constant.character.escape.hexadecimal
#      ^ - constant.character.escape

    \U0a
#  ^ - constant.character.escape
#   ^^^^ constant.character.escape.hexadecimal
#       ^ - constant.character.escape

    \U0a5f
#  ^ - constant.character.escape
#   ^^^^^^ constant.character.escape.hexadecimal
#         ^ - constant.character.escape

    \U0a5g
#  ^ - constant.character.escape
#   ^^^^^ constant.character.escape.hexadecimal
#        ^ - constant.character.escape

    \U0a5fabcd
#  ^ - constant.character.escape
#   ^^^^^^^^^^ constant.character.escape.hexadecimal
#             ^ - constant.character.escape

    \U0a5fabcdddf
#  ^ - constant.character.escape
#   ^^^^^^^^^^ constant.character.escape.hexadecimal
#             ^^^^ - constant.character.escape


##############################################################################
# [10] Comments
#
# If a hash character (“#”) appears at a point where Tcl is expecting the
# first character of the first word of a command then the hash character and
# the characters that follow it, up through the next newline, are treated as a
# comment and ignored.
##############################################################################

    # command \
#  ^ - comment
#   ^ punctuation.definition.comment.begin.tcl
#   ^^^^^^^^^^^^ comment.line.double-dash.tcl
#             ^ - punctuation.separator.continuation.newline.tcl

    cmd#no comment
#      ^ - punctuation
#      ^^^^^^^^^^^^ - comment

    cmd # no comment
#       ^^^^^^^^^^^^^ - comment

    cmd;# no comment
#      ^ punctuation.terminator.command.tcl
#       ^ punctuation.definition.comment.begin.tcl
#       ^^^^^^^^^^^^^ comment.line.double-dash.tcl

    cmd ; # no comment
#       ^ punctuation.terminator.command.tcl
#         ^ punctuation.definition.comment.begin.tcl
#         ^^^^^^^^^^^^^ comment.line.double-dash.tcl

    cmd [# comment]
#       ^ punctuation.section.substitution.begin.tcl
#        ^ punctuation.definition.comment.begin.tcl
#        ^^^^^^^^^^^ comment.line.double-dash.tcl
#                 ^ - punctuation

        cmd [ set;# comment ];comment
#                ^ punctuation.terminator.command.tcl
#                 ^ punctuation.definition.comment.begin.tcl
#                 ^^^^^^^^^^^^^^^^^^^^ comment.line.double-dash.tcl
#                           ^^ - punctuation
            ]
#           ^ meta.substitution.tcl punctuation.section.substitution.end.tcl

        cmd [ set#no comment ]
#           ^ punctuation.section.substitution.begin.tcl
#                ^ - punctuation
#                ^^^^^^^^^^^^^^ - comment
#                            ^ punctuation.section.substitution.end.tcl

        cmd [ set # no comment ]
#           ^ punctuation.section.substitution.begin.tcl
#                 ^ - punctuation
#                 ^^^^^^^^^^^^^^^ - comment
#                              ^ punctuation.section.substitution.end.tcl
       ]
#      ^ punctuation.section.substitution.end.tcl

    set w { # no commet }
#           ^^^^^^^^^^^^^^ - comment

    set w { ; # no commet }
#             ^^^^^^^^^^^^^^ - comment


##############################################################################
# namespace tests
##############################################################################

    namespace \
#   ^^^^^^^^^ keyword.control.flow.namespace.tcl
#             ^ punctuation.separator.continuation.newline.tcl
    eval \
#   ^^^^ keyword.control.flow.eval.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    A \
#   ^ entity.name.namespace.tcl
#     ^ punctuation.separator.continuation.newline.tcl
    {
#^^^ meta.namespace.tcl - meta.braces
#   ^^ meta.namespace.tcl meta.braces
#   ^ punctuation.section.braces.begin.tcl
    }
#^^^^ meta.namespace.tcl meta.braces.tcl
#    ^ meta.namespace.tcl - meta.braces.tcl
#   ^ punctuation.section.braces.end.tcl


    namespace eval A {
#  ^ - meta
#   ^^^^^^^^^^^^^^^^^^^ meta.namespace
#                    ^^ meta.braces
#   ^^^^^^^^^ keyword.control.flow.namespace
#             ^^^^ keyword.control.flow.eval
#                  ^ entity.name.namespace
#                    ^ punctuation.section.braces.begin
        namespace eval B \
#^^^^^^^ meta.namespace
#       ^^^^^^^^^^^^^^^^^^^ meta.namespace meta.namespace
#                    ^^ meta.braces
#       ^^^^^^^^^ keyword.control.flow.namespace
#                 ^^^^ keyword.control.flow.eval
#                      ^ entity.name.namespace
#                        ^ punctuation.separator.continuation.newline
        {
#<- meta.namespace meta.namespace
#       ^ punctuation.section.braces.begin
            proc A {

            }

            proc [proc A {}] {

            }

        }
    }


##############################################################################
# flow control keyword tests
##############################################################################

    break invalid ; # comment
#   ^^^^^ keyword.control.flow.break.tcl
#        ^ - keyword - invalid
#         ^^^^^^^ invalid.illegal.end-of-cmd-expected.tcl
#                ^ - invalid
#                 ^ punctuation.terminator.command.tcl
#                   ^ comment.line.double-dash.tcl

    break-me
#   ^^^^^ - keyword.control.flow

    break[incr x]
#   ^^^^^ - keyword.control.flow

    break(5)
#   ^^^^^ - keyword.control.flow

    continue "test";# comment
#   ^^^^^^^^ keyword.control.flow.continue.tcl
#           ^ - keyword - invalid
#            ^^^^^^ invalid.illegal.end-of-cmd-expected.tcl
#                  ^ punctuation.terminator.command.tcl
#                   ^ comment.line.double-dash.tcl

    continue-me
#   ^^^^^^^^ - keyword.control.flow

    continue[incr x]
#   ^^^^^^^^ - keyword.control.flow

    continue(2)
#   ^^^^^^^^ - keyword.control.flow

    exit

    return
#  ^ - keyword
#   ^^^^^^ keyword.control.flow.return.tcl
#         ^ - keyword
    returnme
#   ^^^^^^^^^ - keyword.control.flow

    return(1)
#   ^^^^^^^^^ - keyword.control.flow

    return 1
#  ^ - keyword
#   ^^^^^^ keyword.control.flow.return.tcl
#         ^ - keyword
#          ^ constant.numeric.integer.tcl

    return -code $code $factor
#  ^ - keyword
#   ^^^^^^ keyword.control.flow.return.tcl
#         ^ - keyword
#          ^^^^^ variable.parameter.tcl
#                ^^^^^ variable.other.tcl
#                      ^^^^^^^ variable.other.tcl

    return -code error \
#  ^ - keyword
#   ^^^^^^ keyword.control.flow.return.tcl
#         ^ - keyword
#          ^^^^^ variable.parameter.tcl
#                ^^^^^ constant.language.tcl
        "overflow computing factorial of $n"
#       ^ string.quoted.double.tcl punctuation.definition.string.begin.tcl

##############################################################################
# if-else tests
##############################################################################

    if true {} elseif false {} else {} ; if false {cmd arg}
#   ^^ keyword.control.flow.if.tcl
#      ^^^^ constant.language.tcl
#           ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#            ^ meta.braces.tcl punctuation.section.braces.end.tcl
#              ^^^^^^ keyword.control.flow.elseif.tcl
#                     ^^^^^ constant.language.tcl
#                           ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#                            ^ meta.braces.tcl punctuation.section.braces.end.tcl
#                              ^^^^ keyword.control.flow.else.tcl
#                                   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#                                    ^ meta.braces.tcl punctuation.section.braces.end.tcl
#                                      ^ punctuation.terminator.command.tcl
#                                        ^^ keyword.control.flow.if.tcl
#                                           ^^^^^ constant.language.tcl
#                                                 ^ punctuation.section.braces.begin.tcl
#                                                 ^^^^^^^^^ meta.braces.tcl
#                                                         ^ punctuation.section.braces.end.tcl

# check line continuation as word break without preceding whitespace
    if\
#   ^^ keyword.control.flow.if.tcl
#     ^ punctuation.separator.continuation.newline.tcl
    true\
#   ^^^^ constant.language.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    {cmd arg arg}\
#   ^ punctuation.section.braces.begin.tcl
#   ^^^^^^^^^^^^^ meta.braces.tcl
#    ^^^ variable.function.tcl
#               ^ punctuation.section.braces.end.tcl
#                ^ punctuation.separator.continuation.newline.tcl
    elseif\
#   ^^^^^^ keyword.control.flow.elseif.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    false\
#   ^^^^^ constant.language.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    {}\
#   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#    ^ meta.braces.tcl punctuation.section.braces.end.tcl
#     ^ punctuation.separator.continuation.newline.tcl
    elseif\
#   ^^^^^^ keyword.control.flow.elseif.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    [puts\
#   ^ punctuation.section.substitution.begin.tcl
#   ^^^^^^^^ meta.substitution.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    "true"]\
# <- meta.substitution.tcl
#^^^^^^^^^^ meta.substitution.tcl
#   ^^^^^^ string.quoted.double.tcl
#         ^ punctuation.section.substitution.end.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    {}\
#   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#    ^ meta.braces.tcl punctuation.section.braces.end.tcl
#     ^ punctuation.separator.continuation.newline.tcl
    else\
#   ^^^^ keyword.control.flow.else.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    {}
#   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#    ^ meta.braces.tcl punctuation.section.braces.end.tcl

# check line continuation with preceding whitespace
    if \
#   ^^ keyword.control.flow.if.tcl
#      ^ punctuation.separator.continuation.newline.tcl
    true \
#   ^^^^ constant.language.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    {cmd arg arg} \
#   ^ punctuation.section.braces.begin.tcl
#   ^^^^^^^^^^^^^ meta.braces.tcl
#    ^^^ variable.function.tcl
#               ^ punctuation.section.braces.end.tcl
#                 ^ punctuation.separator.continuation.newline.tcl
    elseif \
#   ^^^^^^ keyword.control.flow.elseif.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    false \
#   ^^^^^ constant.language.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    {} \
#   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#    ^ meta.braces.tcl punctuation.section.braces.end.tcl
#      ^ punctuation.separator.continuation.newline.tcl
    elseif \
#   ^^^^^^ keyword.control.flow.elseif.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    [puts \
#   ^ punctuation.section.substitution.begin.tcl
#   ^^^^^^^^ meta.substitution.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    "true"] \
# <- meta.substitution.tcl
#^^^^^^^^^^ meta.substitution.tcl
#   ^^^^^^ string.quoted.double.tcl
#         ^ punctuation.section.substitution.end.tcl
#           ^ punctuation.separator.continuation.newline.tcl
    {} \
#   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#    ^ meta.braces.tcl punctuation.section.braces.end.tcl
#      ^ punctuation.separator.continuation.newline.tcl
    else \
#   ^^^^ keyword.control.flow.else.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    {}
#   ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#    ^ meta.braces.tcl punctuation.section.braces.end.tcl

# Ensure else doesn't work outside of if command
    elseif true {}
#   ^^^^^^ invalid.illegal.unexpected.tcl
#          ^^^^ constant.language.tcl
#               ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#                ^ meta.braces.tcl punctuation.section.braces.end.tcl
    else {}
#   ^^^^ invalid.illegal.unexpected.tcl
#        ^ meta.braces.tcl punctuation.section.braces.begin.tcl
#         ^ meta.braces.tcl punctuation.section.braces.end.tcl

    if {$arg eq [set x]} {
#   ^^ keyword.control.flow.if.tcl
#      ^ punctuation.section.braces.begin.tcl
#      ^^^^^^^^^^^^^^^^^ meta.braces.tcl
#       ^^^^ variable.other.tcl
#            ^^ keyword.operator.relational.tcl
#               ^^^^^^^ meta.substitution.tcl
#                      ^ punctuation.section.braces.end.tcl
#                        ^^ meta.braces.tcl
#                        ^ punctuation.section.braces.begin.tcl
        set var 0

        if {$var == 0} {
            puts "bar"
        } else {
            puts "baz"
        }

    } elseif [puts "true"] {

        puts "foo"
    } else {
        puts "bar"
    }

    if {[catch {ns::func -class interface \
#   ^^^ meta.statement.conditional.tcl
#      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl
#   ^^ keyword.control.flow.if.tcl
#      ^ punctuation.section.braces.begin.tcl
#       ^ punctuation.section.substitution.begin.tcl
#        ^^^^^ keyword.control.flow.catch.tcl
#              ^ punctuation.section.braces.begin.tcl
#               ^^^^^^^^ meta.command.tcl variable.function.tcl
#                 ^^ punctuation.accessor.colon.tcl
#                        ^^^^^^ variable.parameter.tcl
#                                         ^ punctuation.separator.continuation.newline.tcl
        -flags "statistics,interfaceautoprobe" \
#<- meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.braces.tcl
#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.braces.tcl
#       ^^^^^^ variable.parameter.tcl
#              ^ punctuation.definition.string.begin.tcl
#              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string.quoted.double.tcl
#                         ^ - punctuation
#                                            ^ punctuation.definition.string.end.tcl
#                                              ^ punctuation.separator.continuation.newline.tcl
        -name $aggrname -role $extra_role \
#<- meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.braces.tcl
#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.braces.tcl
#       ^^^^^ variable.parameter.tcl
#             ^^^^^^^^^ variable.other.tcl
#                       ^^^^^ variable.parameter.tcl
#                             ^^^^^^^^^^^ variable.other.tcl
#                                         ^ punctuation.separator.continuation.newline.tcl
                        -parameters [array get params] \
#<- meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.braces.tcl
#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.braces.tcl
#                       ^^^^^^^^^^^ variable.parameter.tcl
#                                   ^ punctuation.section.substitution.begin.tcl
#                                   ^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.braces.tcl meta.substitution.tcl
#                                    ^^^^^ keyword.other.builtin.tcl
#                                                    ^ punctuation.section.substitution.end.tcl
#                                                      ^ punctuation.separator.continuation.newline.tcl
        -opaque [list "becs.editor" "ifrole.tcl"] \
#<- meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.braces.tcl
#^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.braces.tcl
#       ^^^^^^^ variable.parameter.tcl
#               ^ punctuation.section.substitution.begin.tcl
#               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.braces.tcl meta.substitution.tcl
#                ^^^^ keyword.other.builtin.tcl
#                     ^ punctuation.definition.string.begin.tcl
#                     ^^^^^^^^^^^^^ string.quoted.double.tcl
#                          ^ - punctuation
#                                 ^ punctuation.definition.string.end.tcl
#                                  ^ - string
#                                   ^ punctuation.definition.string.begin.tcl
#                                   ^^^^^^^^^^^^ string.quoted.double.tcl
#                                        ^ - punctuation
#                                              ^ punctuation.definition.string.end.tcl
#                                               ^ punctuation.section.substitution.end.tcl
#                                                 ^ punctuation.separator.continuation.newline.tcl
        -parentoid $aggr_attach_oid} err]} {
#<- meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.braces.tcl
#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl meta.braces.tcl
#       ^^^^^^^^^^ variable.parameter.tcl
#                  ^^^^^^^^^^^^^^^^ variable.other.tcl
#                                  ^ punctuation.section.braces.end.tcl
#                                   ^^^^^ meta.statement.conditional.tcl meta.braces.tcl meta.substitution.tcl
#                                       ^ punctuation.section.substitution.end.tcl
#                                        ^ meta.statement.conditional.tcl meta.braces.tcl punctuation.section.braces.end.tcl - meta.substitution
#                                         ^ meta.statement.conditional.tcl - meta.braces - meta.substitution - punctuation
#                                          ^ meta.statement.conditional.tcl meta.braces.tcl punctuation.section.braces.begin.tcl
        return "Creating aggregator interface $aggrname under element/management element-module OID $aggr_attach_oid: $err"
#<- meta.statement.conditional.tcl meta.braces.tcl
    }
#   ^ meta.statement.conditional.tcl meta.braces.tcl punctuation.section.braces.end.tcl

##############################################################################
# for loop tests
##############################################################################


    # for loop execution
    for {set a 10} {$a < 20} {incr a} {
       puts "value of a: $a"
    }


    foreach i {
       GigabitEthernet1/18
       Serial2/2/0.1/2/1/1:0
       Serial2/2/0.1/2/1/2:0
       Serial2/2/0.1/2/1/3:0
       Serial2/2/0.1/2/2/1:0
       Serial2/2/0.1/2/2/2:0
       Serial2/2/0.1/2/2/3:0
       GigabitEthernet9/24
    } {
        set int [exec "show run inter $i | in Serial"]
        if {[regexp "Serial" $int ]} {
            puts "interface $i"
            puts "encap ppp"
        } else {
           puts "interface $i"
           puts "cdp enable"
           puts "Dampening"
           puts "no sh"
        }
    }

##############################################################################
# array commands
##############################################################################

    array set cpe_param [objectGetField -oid $cpeoid -fieldname parameters]
#   ^^^^^ keyword.other.builtin.tcl
#         ^^^ variable.function.tcl
#             ^^^^^^^^^ variable.other.tcl
#                       ^ punctuation.section.substitution.begin.tcl
#                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.substitution.tcl
#                                                                         ^ punctuation.section.substitution.end.tcl

    array names list_name -glob "pa?[A-z]ttern"
#   ^^^^^ keyword.other.builtin.tcl
#        ^ - keyword - variable
#         ^^^^^ variable.function.tcl
#              ^ - variable
#               ^^^^^^^^^ variable.other.tcl
#                        ^ - variable
#                         ^^^^^ variable.parameter.tcl
#                              ^ - variable - string
#                               ^ punctuation.definition.string.begin.tcl
#                               ^^^^^^^^^^^^^^^ string.quoted.double.tcl
#                                  ^ constant.other.placeholder.tcl
#                                   ^^^^^ meta.bracket.tcl constant.other.placeholder.tcl
#                                             ^ punctuation.definition.string.end.tcl
#                                              ^ - string

    array\
#   ^^^^^ keyword.other.builtin.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    names\
#   ^^^^^ variable.function.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    list_name\
#   ^^^^^^^^^ variable.other.tcl
#            ^ punctuation.separator.continuation.newline.tcl
    -glob\
#   ^^^^^ variable.parameter.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    "pa?[A-z]ttern"
#  ^ - variable - string
#   ^ punctuation.definition.string.begin.tcl
#   ^^^^^^^^^^^^^^^ string.quoted.double.tcl
#      ^ constant.other.placeholder.tcl
#       ^^^^^ meta.bracket.tcl constant.other.placeholder.tcl
#                 ^ punctuation.definition.string.end.tcl
#                  ^ - string

    array \
#   ^^^^^ keyword.other.builtin.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    names \
#   ^^^^^ variable.function.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    list_name \
#   ^^^^^^^^^ variable.other.tcl
#             ^ punctuation.separator.continuation.newline.tcl
    -glob \
#   ^^^^^ variable.parameter.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    "pa?[A-z]ttern"
#  ^ - variable - string
#   ^ punctuation.definition.string.begin.tcl
#   ^^^^^^^^^^^^^^^ string.quoted.double.tcl
#      ^ constant.other.placeholder.tcl
#       ^^^^^ meta.bracket.tcl constant.other.placeholder.tcl
#                 ^ punctuation.definition.string.end.tcl
#                  ^ - string

##############################################################################
# after commands
##############################################################################

    set id [after 10 [puts "done!"]]
#           ^^^^^ keyword.other.builtin.tcl

    after cancel $id
#   ^^^^^ keyword.other.builtin.tcl
#         ^^^^^^ constant.language.tcl
#                ^^^ variable.other.tcl

    after\
#   ^^^^^ keyword.other.builtin.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    cancel\
#   ^^^^^^ constant.language.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    $id
#   ^^^ variable.other.tcl

    after info $id
#   ^^^^^ keyword.other.builtin.tcl
#         ^^^^ constant.language.tcl
#              ^^^ variable.other.tcl

    after idle [list after 0 doOneStep]
#   ^^^^^ keyword.other.builtin.tcl
#         ^^^^ constant.language.tcl
#              ^^^^^^^^^^^^^^^^^^^^^^^^ meta.substitution.tcl

    after\
#   ^^^^^ keyword.other.builtin.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    $event\
#   ^^^^^^ variable.other.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    $id
#   ^^^ variable.other.tcl

##############################################################################
# regexp commands
##############################################################################

# -------------------------------------------------#
# https://github.com/sublimehq/Packages/issues/779
# ------------------------------------------------ #
regexp -inline -all -- {%[a-zA-Z_]*%} "whatever"
#      ^^^^^^^^^^^^^^^^ - string

regexp -all -inline {%[a-zA-Z_]*%} "whatever"
#      ^^^^^^^^^^^^^ - string

    regexp {instance="?([^" \t]+)"?} $counter matchedstring instance; # comment
#   ^^^^^^ keyword.other.builtin.tcl
#         ^ - keyword - meta.braces - string
#          ^ punctuation.section.braces.begin.tcl
#          ^^^^^^^^^^^^^^^^^^^^^^^^^ meta.braces.tcl
#           ^^^^^^^^^^^^^^^^^^^^^^^ string.regexp
#                                  ^ punctuation.section.braces.end.tcl
#                                   ^ - meta.braces - string
#                                    ^^^^^^^^ variable.other.tcl
#                                             ^^^^^^^^^^^^^^^^^^^^^^ meta.function-call.tcl
#                                                                   ^ punctuation.terminator.command.tcl
#                                                                     ^ comment.line.double-dash.tcl punctuation.definition.comment.begin.tcl

    set check1 [regexp {^'(.){0,32}'$} $param]
    #                   ^^^^^^^^^^^^^ string.regexp

    set check2 [regexp {[*\?\|"<>:/\]]+} $param]
    #                   ^^^^^^^^^^^^^^^ string.regexp

    set stepquote [regsub -all {"} $line {""} ]
    #                             ^ - string

    # regexp  -- -na

    regsub
#   ^^^^^^ keyword.other.builtin.tcl

    regsub ; regexp;#
#   ^^^^^^ keyword.other.builtin.tcl
#          ^ punctuation.terminator.command.tcl
#            ^^^^^^ keyword.other.builtin.tcl
#                  ^ punctuation.terminator.command.tcl
#                   ^ comment.line.double-dash.tcl punctuation.definition.comment.begin.tcl

    regsub -start 5 -all -- -all\b[set var] $var
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^^ variable.parameter.regexp.tcl
#                 ^ constant.numeric.integer.tcl
#                   ^^^^ variable.parameter.regexp.tcl
#                        ^^ punctuation.terminator.switches.tcl
#                           ^^^^^^^^^^^^^^^ string.unquoted.tcl string.regexp.tcl
#                                 ^ punctuation.section.substitution.begin.tcl
#                                 ^^^^^^^^^ meta.substitution.tcl
#                                         ^ punctuation.section.substitution.end.tcl
#                                           ^^^^ variable.other.tcl

    regsub -all {[A-z]\d+na\/\b} $line {\\} line
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^ variable.parameter.regexp.tcl
#               ^ punctuation.section.braces.begin.tcl
#               ^^^^^^^^^^^^^^^^ meta.braces.tcl
#                              ^ punctuation.section.braces.end.tcl
#                                ^^^^^ variable.other.tcl
#                                      ^ punctuation.section.braces.begin.tcl
#                                      ^^^^ meta.braces.tcl
#                                         ^ punctuation.section.braces.end.tcl

    regsub\
#   ^^^^^^ keyword.other.builtin.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    -all\
#   ^^^^ variable.parameter.regexp.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    {[A-z]\d+na\/\b}\
#   ^ punctuation.section.braces.begin.tcl
#   ^^^^^^^^^^^^^^^^ meta.braces.tcl
#                  ^ punctuation.section.braces.end.tcl
#                   ^ punctuation.separator.continuation.newline.tcl
    $line\
#   ^^^^^ variable.other.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    {\\}\
#   ^ punctuation.section.braces.begin.tcl
#   ^^^^ meta.braces.tcl
#      ^ punctuation.section.braces.end.tcl
#       ^ punctuation.separator.continuation.newline.tcl
    line
#   ^^^^ - keyword.other

    regsub -all "[A-z]\d+na\/\b" $line "\\" line
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^ variable.parameter.regexp.tcl
#               ^ punctuation.definition.string.begin.tcl
#               ^^^^^^^^^^^^^^^^ string.quoted.double.tcl string.regexp.tcl
#                              ^ punctuation.definition.string.end.tcl
#                                ^^^^^ variable.other.tcl
#                                      ^ punctuation.definition.string.begin.tcl
#                                      ^^^^ string.quoted.double.tcl string.regexp
#                                         ^ punctuation.definition.string.end.tcl

##############################################################################
# string commands
##############################################################################

    string compare $str1 $str2; string last $str3
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^^^ variable.function.string.tcl
#                  ^^^^^ variable.other.tcl
#                        ^^^^^ variable.other.tcl
#                             ^ punctuation.terminator.command.tcl
#                               ^^^^^^ keyword.other.builtin.tcl
#                                      ^^^^ variable.function.string.tcl
#                                           ^^^^^ variable.other.tcl

    string\
#   ^^^^^^ keyword.other.builtin.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    compare\
#   ^^^^^^^ variable.function.string.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    $str1\
#   ^^^^^ variable.other.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    $str2
#   ^^^^^ variable.other.tcl

    string \
#   ^^^^^^ keyword.other.builtin.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    compare \
#   ^^^^^^^ variable.function.string.tcl
#           ^ punctuation.separator.continuation.newline.tcl
    $str1 \
#   ^^^^^ variable.other.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    $str2
#   ^^^^^ variable.other.tcl

    string is ascii "my ascii"
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^ variable.function.string.tcl
#             ^^^^^ storage.type.tcl
#                   ^^^^^^^^^^ string.quoted.double.tcl

    string is inval "my ascii"
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^ variable.function.string.tcl
#             ^^^^^ - storage.type.tcl
#                   ^^^^^^^^^^ string.quoted.double.tcl

    string inval $str
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^ - variable.function.string.tcl
#                ^^^^ variable.other.tcl

    string match "patt[-[\]_A-z]r?n" $str
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^ variable.function.string.tcl
#                ^ punctuation.definition.string.begin.tcl
#                ^^^^^^^^^^^^^^^^^^^ string.quoted.double.tcl
#                     ^ punctuation.section.bracket.begin.tcl
#                     ^^^^^^^^^^ meta.bracket.tcl constant.other.placeholder.tcl
#                      ^ - punctuation.separator
#                        ^^ constant.character.escape.tcl
#                            ^  punctuation.separator.sequence.tcl
#                              ^ punctuation.section.bracket.begin.tcl
#                                ^ constant.other.placeholder.tcl
#                                  ^ punctuation.definition.string.end.tcl
#                                    ^^^^ variable.other.tcl

    string\
#   ^^^^^^ keyword.other.builtin.tcl
#         ^ punctuation.separator.continuation.newline.tcl
    match\
#  ^ - variable.function
#   ^^^^^ variable.function.string.tcl
#        ^ punctuation.separator.continuation.newline.tcl
    -nocase\
#   ^^^^^^^ variable.parameter.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    "patt[-[\]_A-z]r?n" $str
#   ^^^^^^^^^^^^^^^^^^^ string.quoted.double.tcl
#        ^ punctuation.section.bracket.begin.tcl
#        ^^^^^^^^^^ meta.bracket.tcl constant.other.placeholder.tcl
#         ^ - punctuation.separator
#           ^^ constant.character.escape.tcl
#               ^  punctuation.separator.sequence.tcl
#                 ^ punctuation.section.bracket.begin.tcl
#                   ^ constant.other.placeholder.tcl
#                     ^ punctuation.definition.string.end.tcl
#                       ^^^^ variable.other.tcl

    string \
#   ^^^^^^ keyword.other.builtin.tcl
#          ^ punctuation.separator.continuation.newline.tcl
    match \
#  ^ - variable.function
#   ^^^^^ variable.function.string.tcl
#        ^ - variable.function
#         ^ punctuation.separator.continuation.newline.tcl
    -nocase \
#   ^^^^^^^ variable.parameter.tcl
#           ^ punctuation.separator.continuation.newline.tcl
    "p\?a\*t\[t\]
#  ^ - string
#   ^ punctuation.definition.string.begin.tcl
#   ^^^^^^^^^^^^^^ string.quoted.double.tcl
#     ^^ constant.character.escape.other.tcl - constant.other.placeholder
#        ^^ constant.character.escape.other.tcl - constant.other.placeholder
#           ^^ constant.character.escape.other.tcl - punctuation
#              ^^ constant.character.escape.other.tcl - punctuation
    [_A-z]*r?n
#^^^^^^^^^^^^^^ string.quoted.double.tcl
#   ^ punctuation.section.bracket.begin.tcl
#        ^ punctuation.section.bracket.begin.tcl
#         ^ constant.other.placeholder.tcl
#           ^ constant.other.placeholder.tcl
    " $str
# <- string.quoted.double.tcl
#   ^ string.quoted.double.tcl punctuation.definition.string.end.tcl
#    ^ - string
#     ^^^^ variable.other.tcl

    string match -nocase {p\?a\*t\[t\][_A-z]*r?n} $str
#   ^^^^^^ keyword.other.builtin.tcl
#          ^^^^^ variable.function.string.tcl
#                ^^^^^^^ variable.parameter.tcl
#                        ^ punctuation.section.braces.begin.tcl
#                        ^^^^^^^^^^^^^^^^^^^^^^^^ meta.braces.tcl string.quoted.brace.tcl
#                          ^^ constant.character.escape.other.tcl - constant.other.placeholder
#                             ^^ constant.character.escape.other.tcl - constant.other.placeholder
#                                ^^ constant.character.escape.other.tcl - punctuation
#                                   ^^ constant.character.escape.other.tcl - punctuation
#                                     ^ punctuation.section.bracket.begin.tcl
#                                          ^ punctuation.section.bracket.begin.tcl
#                                           ^ constant.other.placeholder.tcl
#                                             ^ constant.other.placeholder.tcl
#                                               ^ punctuation.section.braces.end.tcl

##############################################################################
# list commands
##############################################################################

    lappend listName value
